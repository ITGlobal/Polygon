// CQG Web API server protocol

package WebAPI_1;

import "shared_1.proto";
import "timestamp.proto";
import "rules_1.proto";

// Last changes were made on 2 Oct 2017
// Version 1.78 - (version number is constructed as 'MAJOR.MINOR' from the following enums)
enum ProtocolVersionMajor
{
   // Major number change is required for backward incompatible protocol versions (new 'proto' file is necessary)
   PROTOCOL_VERSION_MAJOR = 1;
}
enum ProtocolVersionMinor
{
   // Minor number is increased for backward compatible protocol versions when new messages and/ or fields are
   // added without removing/ changing any existing messages and fields (new 'proto' file is not created)
   PROTOCOL_VERSION_MINOR = 78;
}

// Protocol rules:
// 1)  CamelCase with an initial capital is used for message names while fields are lowercase underscore_separated_names
//     (see https://developers.google.com/protocol-buffers/docs/style)
// 3)  Key numbers for existing fields must stay the same between minor protocol version changes.
// 4)  Negative values for enums and key numbers are prohibited.
// 5)  Only explicit signed (e.g. sint32) and unsigned (e.g. uint64) integer types must be used. Usage of implicit signed integer
//     types (e.g. int16) is prohibited since they are not supported by JS client library and consume a lot of space for 
//     negative values.
// 6)  Unsigned types should be used for fields that cannot have negative values. This allows to minimize their size.
// 7)  Field numbers < 16 takes one byte for a key/ wire-type header so numbers > 16 should be used for optional and infrequently used fields.
//     do not 'reserve' field numbers without real reasons.
//     See https://developers.google.com/protocol-buffers/docs/encoding for details.
// 8)  Field numbers don't always come in a strict order and so allow to place new fields next to logically related ones.
// 9)  'Result' suffix is used in responses when only a single response is possible.
// 10)  'Status' suffix is used a separate message for a status of a subscription when subscriptions are not optional.
// 11) 'Report' suffix is used in responses when 'Result' and 'Data' are combined in a single message and when subscription is optional,
//     this allows to avoid two messages if subscription is not requested.
// 12) Time attributes that are 64-bit signed integers contain offset in milliseconds from base_time attribute of the logon and
//     session restore/join results.
// 13) Client implementation must be ready to get new values of any field associated with enum specified in this protocol
//     (all these fields are made uint32 to make protocol backward compatible for such changes). So when client gets unknown value it should
//     either ignore it or check whether it relates to failure (e.g. whether it's > 100 for StatusCode/ResultCode fields).


// Client to Server message, must include at least one field.
// Logon, LogonRoutineClient, RestoreOrJoinSession or ObtainDemoCredentials are required to be the first and the only message after connection.
// Client messages rate is limited, 1000 messages per 10 seconds by default.
// If this rate is exceeded then a user message is sent with details and the connection is closed.
// NOTE: This and other limits mentioned in this protocol are not guaranteed, they are given for reference only
// and are subject to change without prior notice.
message ClientMsg
{
   // Session level messages from client.
   optional Logon logon = 100;
   optional RestoreOrJoinSession restore_or_join_session = 101;
   optional Logoff logoff = 102;
   optional PasswordChange password_change = 103;
   optional ObtainDemoCredentials obtain_demo_credentials = 104;
   optional UserSessionStateRequest user_session_state_request = 105;
   optional Ping ping = 107;
   optional Pong pong = 108;
   optional LogonRoutineClient logon_routine_client = 109;
   optional PasswordChangeRoutineClient password_change_routine_client = 110;

   // Requests for different information with optional subscription for updates.
   // There are the following limits for information requests:
   // 1) Information requests rate is limited, 1000 requests per 100 seconds by default.
   // 2) Number of simultaneous information subscriptions is limited, a separate limit per information request type is used.
   // 3) Number of overall information requests per session is limited, a separate limit per information request type is used.
   repeated InformationRequest information_request = 1;
   
   // Trade routing subscriptions from client.
   // There are the following limits for trade routing subscriptions:
   // 1) Number of simultaneous subscriptions is limited, 200 by default.
   // 2) Total number of either explicitly or implicitly subscribed accounts is limited, 5000 by default.
   //    Any subscription that leads to exceeding this limit is failed.
   repeated TradeSubscription trade_subscription = 2;

   // Order requests.
   // Requests rate is limited, 300 orders per 10 seconds per account by default.
   repeated OrderRequest order_request = 3;

   // Market data subscriptions from client.
   // Subscriptions number is limited, 200 simultaneous subscriptions by default.
   // Subscriptions on options strikes (puts and calls) of the same option maturity are considered as a single subscription within the limit.
   repeated MarketDataSubscription market_data_subscription = 4;

   // Requests for manipulations with user attributes (linked to the user and client_app_id).
   // There are the following limits for user attributes:
   //  1) storage space is limited, 100 KB by default for a user/client_app_id pair;
   //  2) requests rate is limited, 10 requests per 100 seconds by default.
   repeated ReadUserAttributeRequest read_user_attribute_request = 5;
   repeated ModifyUserAttributeRequest modify_user_attribute_request = 6;

   // Historical data requests.
   // Number of simultaneous historical requests in processing is limited, 10 by default.
   repeated TimeAndSalesRequest time_and_sales_request = 7;
   repeated TimeBarRequest time_bar_request = 8;
   repeated VolumeProfileRequest volume_profile_request = 9;

   // Rules requests.
   // Number of simultaneous defined rules is limited, 100 by default.
   repeated rules_1.RuleRequest rule_request = 10;
}

// Server to Client message, server can include different fields in a single message
message ServerMsg
{
   // Session level messages from server.
   optional LogonResult logon_result = 100;
   optional RestoreOrJoinSessionResult restore_or_join_session_result = 101;
   repeated ConcurrentConnectionJoin concurrent_connection_join = 111;
   optional LoggedOff logged_off = 102;
   optional PasswordChangeResult password_change_result = 103;
   repeated UserMessage user_message = 104;
   repeated ObtainDemoCredentialsResult obtain_demo_credentials_result = 105;
   repeated UserSessionStateResult user_session_state_result = 106;
   optional Ping ping = 107;
   optional Pong pong = 108;
   optional LogonRoutineServer logon_routine_server = 109;
   optional PasswordChangeRoutineServer password_change_routine_server = 110;

   // Reports with requested information.
   repeated InformationReport information_report = 1;

   // Trade routing messages from server.
   repeated OrderRequestReject order_request_reject = 2;
   repeated TradeSubscriptionStatus trade_subscription_status = 3;
   repeated TradeSnapshotCompletion trade_snapshot_completion = 4;
   repeated OrderStatus order_status = 5;
   repeated PositionStatus position_status = 6;
   repeated CollateralStatus collateral_status = 7;

   // Market data messages from server.
   repeated MarketDataSubscriptionStatus market_data_subscription_status = 8;
   repeated RealTimeMarketData real_time_market_data = 9;

   /// Results of user attributes operations.
   repeated ReadUserAttributeResult read_user_attribute_result = 10;
   repeated ModifyUserAttributeResult modify_user_attribute_result = 11;

   /// Historical data.
   repeated TimeAndSalesReport time_and_sales_report = 12;
   repeated TimeBarReport time_bar_report = 13;
   repeated VolumeProfileReport volume_profile_report = 14;

   // Results of rules requests.
   repeated rules_1.RuleResult rule_result = 15;
}

////------------------------------------------
//// Session level messaging

// Placeholder message of real-time Collapsing level enumeration (some libraries do not support enumerations outside of messages)
// Collapsing is a mechanism of eliminating some intermediate quotes to present more up-to-date market data
// instead of falling behind.
// It is started dynamically by server if client is not able to consume all requested feed timely
// e.g. because of a narrow network channel or client side hardware/ software issues.
message RealTimeCollapsing
{
   enum Level
   {
      // Collapsing is not not preferred.
      NONE = 0;

      // DOM data is collapsed.
      DOM = 1;

      // DOM and best bid/ ask quotes are collapsed delivering only last BBA but all trades.
      DOM_BBA = 2;

      // DOM, best bid/ ask and trades quotes are collapsed delivering only last values.
      DOM_BBA_TRADES = 3;
   }
}

// Logon into the system and opening a new session.
// Clients should either use user_name/password or access_token to enter the system.
message Logon
{
   // User login name.
   // It is not used along with access_token.
   optional string user_name = 1;

   // User's password.
   // It is not used along with access_token.
   optional string password = 2;

   // Access token.
   // It is not used along with user_name, password and one_time_password.
   optional string access_token = 14;

   // User's one time password, might be required according to the user's settings.
   optional string one_time_password = 3;

   // Private label identifies the Firm or Vendor that connects to the server, client_app_id field value is taken by default.
   optional string private_label = 4;

   // Identifier of the client application as assigned by CQG.
   required string client_app_id = 5;

   // Version of a client application.
   required string client_version = 6;

   // Optional field that indicates if possible concurrent sessions for this user should be forcedly dropped.
   // If it is set to false then Logon may fail with CONCURRENT_SESSION code.
   // If it is omitted or set to true then concurrent sessions for this user will be dropped.
   optional bool drop_concurrent_session = 7;

   // Maximum allowed real-time market data collapsing level.
   // DOM_BBA_TRADES is the default allowed collapsing level.
   // This field is associated with RealTimeCollapsing.Level enum type.
   // Only one of collapsing_level and bandwidth can be specified.
   optional uint32 collapsing_level = 8;

   // Current protocol version that is used by the client application.
   // It is strongly recommended for client applications to put PROTOCOL_VERSION_MAJOR and PROTOCOL_VERSION_MINOR values from a used protocol file.
   // If version information is not provided then Server assumes client uses 0.x version of the protocol and may disable some new protocol features.
   optional uint32 protocol_version_minor = 9;
   optional uint32 protocol_version_major = 10;

   enum SessionSetting
   {
      // Allows restoring session in case of an accidental disconnect (see RestoreOrJoinSession message).
      // If the setting is not specified then termination of the last connection also terminates the session without ability to restore it.
      // For security reasons clients should not specify this setting without using the restore session functionality.
      ALLOW_SESSION_RESTORE = 1;

      // Allows other new connections to join the session (see RestoreOrJoinSession message) and work concurrently.
      // If the setting is not specified then the session can have only one connection at each moment and a new connection pushes the old one out (if the session restore is allowed).
      // For security reasons clients should not specify this setting without using join session functionality.
      ALLOW_SESSION_JOIN = 2;
   }

   // List of settings for a new session.
   // This field is associated with SessionSetting enum type.
   repeated uint32 session_settings = 11;

   // Real-time market data bandwidth limit (in KB per second).
   // Only one of collapsing_level and bandwidth can be specified.
   optional uint32 bandwidth = 12;

   // Dialect ID for used symbols.
   // CQG dialect is used if omitted.
   // Id for CQG dialect is 0.
   // Please contact CQG to get the list of supported dialects.
   optional string dialect_id = 13;
}

// Result of the logon operation (for Logon and LogonRoutineClient messages).
message LogonResult
{
   enum ResultCode
   {
      //// success codes
      // User is logged in to the system.
      SUCCESS = 0;

      //// failure codes (100+)
      // General failure.
      FAILURE = 101;

      // One-time password is required for this user but it was not sent, repeat logon
      // with one-time password.
      NO_ONETIME_PASSWORD = 103;

      // User password is expired, only change password operation is allowed.
      PASSWORD_EXPIRED = 104;

      // Failed because this user has a concurrent session that is
      // not allowed for this application and drop was not requested.
      CONCURRENT_SESSION = 105;

      // Client is redirected to a different server, new server is specified in redirectUrl.
      REDIRECTED = 106;

      // The negotiation rules for LogonRoutineClient have been violated, e.g. user has specified several fields at once in one message.
      ROUTINE_ERROR = 107;

      // Access token is expired already.
      ACCESS_TOKEN_EXPIRED = 108;
   }

   // One of the logon result codes.
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 1;

   // Base time as ISO 8601 string (e.g. '2013-04-03T14:23:20')
   // all other times are number of milliseconds from this base time.
   required string base_time = 2;

   // Token of a new session if logon succeeded.
   optional string session_token = 3;

   // Optional logon result message for failure details.
   optional string text_message = 4;

   // URL for a client to reconnect in case of redirection.
   optional string redirect_url = 5;

   // Current protocol version of server. Normally client application need nothing to do with it.
   required uint32 protocol_version_minor = 6;
   required uint32 protocol_version_major = 7;

   // Unique user identification
   optional sint32 user_id = 8;

   // The time at which the message was sent
   required sint64 server_time = 9;
}

// Message for multi-step logon which user should use in case if it is required to use encoded password.
// Multi-step logon sequence has the following steps:
//      1) Client initiates logon negotiation by sending LogonRoutineClient.logon_init message to the server.
//      2) Server sends one or more LogonRoutineServer.password_request messages (this step may repeat after step #3).
//      3) Client sends list of LogonRoutineClient.password_response back to the server.
//      4) Server optionally asks accept trader's agreement (LogonRoutineServer.trader_agreement_url).
//      5) Client responds with LogonRoutineClient.trader_agreement_accepted equal to True
//         if the user accepts agreement, False or LogonRoutineClient.abort_logon otherwise.
//      6) Server sends LogonRoutineServer.logon_result as the final message of the negotiation with the results.
//   Client may stop the negotiation by sending LogonRoutineClient.abort_logon message in response to any server
//      LogonRoutineServer.password_request or LogonRoutineServer.trader_agreement_url requests.
// NOTE: only one of fields has to be specified.
message LogonRoutineClient
{
   // Initiating of multi-step logon process by client.
   optional LogonInit logon_init = 1;

   // List of passwords in response to request from server.
   // The number of passwords in response should be equal to the number of passwords in request from server.
   repeated PasswordResponse password_response = 2;

   // True means user has accepted the trader agreement.
   optional bool trader_agreement_accepted = 3;

   // Aborting of multi-step logon process by client.
   optional AbortRoutine abort_logon = 4;
}

// Response to the LogonRoutineClient message. Only one of fields is specified.
message LogonRoutineServer
{
   // Final message of the negotiation with the results.
   optional LogonResult logon_result = 1;

   // List of requested passwords.
   repeated PasswordRequest password_request = 2;

   // URL pointing to the location of help information for this version of agreement.
   // Specified if user should accept trader's agreement in order to continue logon process.
   optional string trader_agreement_url = 3;
}

// Message for multi-step password change which user should use in case if it is required to use encoded password.
// Multi-step password change sequence has the following steps:
//      1) Client initiates password change procedure by sending PasswordChangeRoutineClient.init_password_change to the server.
//      2) Server sends one or more PasswordChangeRoutineServer.password_request messages (this step may repeat after step #3).
//      3) Client sends list of PasswordChangeRoutineClient.password_response back to the server.
//      4) Server sends PasswordChangeRoutineServer.password_change_result as the final message of the negotiation with the results.
//   Client may stop the negotiation by sending PasswordChangeRoutineClient.abort_password_change message in response to any server
//      PasswordChangeRoutineServer.password_request message.
// NOTE: only one of fields has to be specified.
message PasswordChangeRoutineClient
{
   // True means user has decided to initiate password changing procedure.
   optional bool init_password_change = 1;

   // List of passwords in response to request from server.
   // The number of passwords in response should be equal to the number of passwords in request from server.
   repeated PasswordResponse password_response = 2;

   // Aborting of multi-step password change process by client.
   optional AbortRoutine abort_password_change = 3;
}

// Response to the PasswordChangeRoutineClient message. Only one of fields is specified.
message PasswordChangeRoutineServer
{
   // List of requested passwords.
   repeated PasswordRequest password_request = 1;

   // Final message of the negotiation with the results.
   optional PasswordChangeResult password_change_result = 2;
}

// This message indicates that user has decided to abort the logon or password change processes.
message AbortRoutine
{
   // Reason of logon or password change routine abort.
   optional string comment = 1;
}

// Initiating of multi-step logon process by client. See description of fields in Logon message.
message LogonInit
{
   required string user_name = 1;
   optional string private_label = 2;
   required string client_app_id = 3;
   required string client_version = 4;
   optional bool drop_concurrent_session = 5;
   optional uint32 collapsing_level = 6;

   optional uint32 protocol_version_minor = 7;
   optional uint32 protocol_version_major = 8;
   repeated uint32 session_settings = 9;
   optional uint32 bandwidth = 10;
   optional string dialect_id = 11;
}

// Parameters of requesting password from user.
message PasswordRequest
{
   enum PasswordType
   {
      // Currently used password.
      STATIC = 1;

      // One-time password.
      ONE_TIME = 2;

      // New password that user wants to use. Can be specified only in result of PasswordChangeRoutineClient.
      NEW_STATIC = 3;

      // Currently used password and new password that user wants to use. Can be specified only in result of PasswordChangeRoutineClient.
      CUR_AND_NEW_STATIC = 4;

      // Non-password request with question e.g. "What is your favourite pet?".
      TEXT = 5;
   }

   // ID of a request.
   required uint32 request_id = 1;

   // Type of password which server requests from the user.
   // This field is associated with PasswordType enum type.
   required uint32 password_type = 2;

   // Commonly understood code that can be used to show an additional localized prompt for certain password types.
   optional string user_prompt_type = 3;

   // Alternate English text for clients which do not recognize user_prompt_type. This text can be displayed as-is to the user.
   // NOTE: user_prompt_type and user_prompt_type_alt are a pair (so either none or both are provided).
   optional string user_prompt_type_alt = 4;

   // Text that should be displayed to the user as-is along with the localized prompt implied by user_prompt_type.
   // If user_prompt_type_alt is used instead, this text should be displayed after it.
   // user_prompt will only be provided if user_prompt_type and user_prompt_type_alt are provided, but it is optional even then.
   optional string user_prompt = 5;

   // Set of supported encodings for this request. Client should choose the encoding with highest priority from among those it implements.
   repeated Encoding encoding = 6;
}

// Response to the PasswordRequest message.
message PasswordResponse
{
   // ID of corresponding password request.
   required uint32 request_id = 1;

   // Commonly understood string that identifies the password encoding method.
   required string encoding_type = 2;

   // User's password encoded with specified encoding method.
   required string password = 3;
}

// Description of the encoding method.
message Encoding
{
   // Commonly understood string that identifies the encoding method.
   // The following encodings are available: "none", "ds3_rsa", "isprint_e2ee".
   required string encoding_type = 1;

   // The priority for this encoding, value 1 is highest priority, 2 is next priority, etc.
   required uint32 priority_rank = 2;

   // Encoding parameters for this encoding method.
   repeated EncodingParameter encoding_parameter = 3;
}

// The encoding parameter.
message EncodingParameter
{
   // Encoding parameter's name.
   required string name = 1;

   // Encoding parameter's value.
   required string value = 2;
}

// Client request to restore session because of accidental disconnect or to join additional concurrent connection to existing session.
// This message allows to avoid prompting user for [one-time] password. 
// In case of session restore client application has to [re-]subscribe and [re-]request necessary data.
// Permissions to use this functionality is regulated by ALLOW_SESSION_RESTORE/ALLOW_SESSION_JOIN session settings which are specified in Logon or LogonInit message.
message RestoreOrJoinSession
{
   // Token of the session to restore/join, it has limited lifetime after disconnect of the last connection.
   required string session_token = 1;

   // Private label identifies the Firm or Vendor that connects to the server, client_app_id field value is taken by default.
   optional string private_label = 2;

   // Identifier of the client application as assigned by CQG.
   // This field is required to be specified and left optional only for backward compatibility.
   optional string client_app_id = 3;

   // Maximum allowed real-time market data collapsing level.
   // DOM_BBA_TRADES is the default allowed collapsing level.
   // This field is associated with RealTimeCollapsing.Level enum type.
   // Only one of collapsing_level and bandwidth can be specified.
   optional uint32 collapsing_level = 4;

   // Current protocol version that is used by the client application.
   // It is strongly recommended for client applications to put PROTOCOL_VERSION_MAJOR and PROTOCOL_VERSION_MINOR values from a used protocol file.
   // If version information is not provided then Server assumes client uses 0.x version of the protocol and may disable some new protocol features.
   optional uint32 protocol_version_minor = 5;
   optional uint32 protocol_version_major = 6;

   // Real-time market data bandwidth limit (in KB per second).
   // Only one of collapsing_level and bandwidth can be specified.
   optional uint32 bandwidth = 7;
}

// Result of session restore or join attempt.
message RestoreOrJoinSessionResult
{
   enum ResultCode
   {
      //// success codes
      // User is logged in to the system.
      SUCCESS = 0;

      //// failure codes (100+)
      // General failure.
      FAILURE = 104;

      // Session is unknown to a server, client must perform standard logon procedure.
      UNKNOWN_SESSION = 101;

      // User is not allowed to perform session restore/join or the maximum connection number has been exceeded.
      ACCESS_DENIED = 102;

      // Some RestoreOrJoinSession message fields were not filled.
      INVALID_PARAMS = 103;
   }

   // Session restore/join result.
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 1;

   // Session base time (see LogonResult.base_time).
   required string base_time = 2;

   // Optional failure details.
   optional string text_message = 3;

   // The time at which the message was sent
   required sint64 server_time = 4;

   // Session default dialect ID for used symbols (see Logon.dialect_id).
   optional string dialect_id = 5;
}

// Notifies about joining of a concurrent connection to the session (see RestoreOrJoinSession).
message ConcurrentConnectionJoin
{
   // Shows if new connection has been initiated by an application of the same type (with the same private_label and client_app_id fields).
   required bool is_same_app_type = 1;
}

// Client request to logoff from the system and close the session.
message Logoff
{
   // Optional logoff reason.
   optional string text_message = 1;
}

// Server notification about closing user's session,
// server closes connection after this message.
message LoggedOff
{
   enum LogoffReason
   {
      // User is logged off by client request.
      BY_REQUEST = 1;

      // User is redirected to another URL.
      REDIRECTED = 2;

      // System logged off the user because of some server side reason.
      FORCED = 3;

      // System logged off the user because this session was re-assigned to another connection
      // that took it over by 'restore session' operation
      REASSIGNED = 4;
   }

   // One of the logoff reasons.
   // This field is associated with LogoffReason enum type.
   required uint32 logoff_reason = 1;

   // Optional logoff details.
   optional string text_message = 2;

   // URL for redirection.
   optional string redirect_url = 3;
}

// Message to change user's password.
message PasswordChange
{
   // Currently used password.
   required string old_password = 1;

   // New password that user wants to use.
   required string new_password = 2;
}

// Result of user password change (for PasswordChange and PasswordChangeRoutineClient messages).
message PasswordChangeResult
{
   // Password change result.
   enum ResultCode
   {
      /// success codes
      // User password is changed successfully.
      SUCCESS = 0;

      /// failure codes (100+)
      // Incorrect user name or password.
      FAILURE = 101;

      // The negotiation rules for PasswordChangeRoutineClient have been violated, e.g. user has specified several fields at once in one message.
      ROUTINE_ERROR = 102;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 1; 

   // Optional failure details.
   optional string text_message = 2;
}

// request for temporary user name and password for demo
// Clients of ObtainDemoCredentials are responcible to verify provided e-mail (e.g. by sending passwords by e-mail only) and prevent possible abuse.
// ObtainDemoCredentials requests are accepted only if client ip address is in the list of allowed IP addresses for service requests
message ObtainDemoCredentials
{
   // Identifier of the client application as assigned by CQG.
   required string client_app_id = 1;

   // User first name
   required string first_name = 2;

   // User second name
   required string second_name = 3;

   // E-mail address of a user who requested demo access.
   required string e_mail = 4;

   // Private label identifies the Firm or Vendor that connects to the server, client_app_id field value is taken by default.
   optional string private_label = 5;
}

message ObtainDemoCredentialsResult
{
   // Password change result.
   enum ResultCode
   {
      /// success codes (0 - 100)
      SUCCESS = 0;

      /// failure codes (100+)
      FAILURE = 101;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 1; 

   // demo user name
   optional string user_name = 2;

   // demo password
   optional string password = 3;

   // Optional details.
   optional string text_message = 4;

   // Unique user identification.
   // Required in case of success.
   optional sint32 user_id = 5;

   // Expiration date/time in UTC as ISO 8601 string (e.g. '2013-04-03T14:23:20Z').
   optional string expiration_utc = 6;
}

// Text message from server.
message UserMessage
{
   // Type of the message.
   enum MessageType
   {
      // Critical error message.
      CRITICAL_ERROR = 1;

      // Warning.
      WARNING = 2;

      // General information.
      INFO = 3;

      // This message shouldn't be visible for users, only dumped into a log file.
      LOG = 4;
   }
   // This field is associated with MessageType enum type.
   required uint32 message_type = 1;

   // Information about source of the message.
   required string source = 2;

   // Message subject.
   optional string subject = 3;

   // Message text.
   required string text = 4;

   // Optional time when this message is expired, it should be hidden from user after this time (UTC).
   optional sint64 expiration_utc_time = 5;
}

// Request information about user session.
// UserSessionState requests are accepted only if client ip address is in the list of allowed IP addresses for service requests
message UserSessionStateRequest
{
   required string session_token = 1;
}

message UserSessionStateResult
{
   // Session token from UserSessionStateRequest.
   required string session_token = 1;

   enum ResultCode
   {
      //// success codes
      // Data for requested session is found.
      SUCCESS = 0;

      //// failure codes (100+)
      // General failure.
      FAILURE = 101;

      // Session is unknown to a server.
      UNKNOWN_SESSION = 102;

      // The user is not allowed to access this data.
      ACCESS_DENIED = 103;
   }

   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   /// User session information.
   optional sint32 user_id = 3;
   optional string username = 4;
}

// Ping request which can be initiated by any side to ensure connection is alive. Both client and
// server sides must respond such request with Pong.
message Ping
{
   // Token routed back in Pong response.
   optional string token = 1;

   // UTC time when this request was composed. Used for network latency diagnostics.
   required sint64 ping_utc_time = 2;
}

// Pong response which must be sent in response on Ping request.
message Pong
{
   // Token passed in Ping request.
   optional string token = 1;

   // Corresponding value from Ping request.
   required sint64 ping_utc_time = 2;

   // UTC time when this response was composed.
   required sint64 pong_utc_time = 3;
}


////------------------------------------------
//// Market and Trade Routing Common messages

// Message to define a synthetic or a user defined strategy, a tree where terminal nodes (legs) are concrete contracts, 
// non-terminal ones are nested strategies.
// Nodes are defined from the BUY perspective.
// Maximum strategy nesting level is 2, i.e. strategy of strategies of legs.
// Maximum number of leg in the whole strategy is 40.
message StrategyDefinition
{
   // Using a fractional trade ratio may result in fractional lots. If so, the number of lots has to be rounded.
   // Rounding applies only to complex strategies with fractional quantity ratios.
   enum RoundLegMode
   {
      // always round down, e.g. 1.1 -> 1 and -2.1 -> -2
      DOWN = 1;

      // always round up, e.g. 1.1 -> 2 and -2.1 -> -3
      UP = 2;

      // round up when fractional part is 5 or greater; round down when fractional part is less than 5, e.g. 1.1 -> 1 and 1.6 -> 2
      MATH = 3;
   }

   // The strategy is of the aggregation type.
   optional bool aggregation = 1;

   // If specified defines exchange strategy.
   optional ExchangeStrategy exchange_strategy = 2;

   // Strategy tick size (correct price format). The tick size of the 1st leg is default.
   optional double tick_size = 3;

   // Additive offset for computation of strategy price.
   // 0 is default.
   optional double price_offset = 4;

   // Controls how to handle fractional quantities when calculating leg quantities for an order on this strategy, 
   // One of RoundLegMode enums, DOWN is default. Ignored for aggregations and exchange strategies.
   optional uint32 round_leg_mode = 5;

   // Unique node index within the root strategy to apply strategy trading parameters and to associate an order.
   required uint32 node_index = 6;

   // Legs or nested strategies.
   repeated StrategyNodeDefinition node_definition = 7;

   // User text associated with the strategy. Allowed to be specified only for non-exchange strategies.
   optional string user_description = 8;
}

// Defines a strategy created by an individual and registered by an exchange for general open market trading.
// Must be a root strategy without nested nodes and cannot be an aggregation.
message ExchangeStrategy
{
   // Value of this field might be chosen from the predefined list to specify exchange strategy type. 
   // Please contact CQG to get the list of supported types.
   // "custom" if omitted.
   optional string exchange_strategy_type = 1;
}

// Defines a leg (resolved contract) of a strategy.
message LegDefinition
{
   // Id of the leg contract.
   required uint32 contract_id = 1;

   // Unique node index within the root strategy to apply strategy trading parameters and to associate an order.
   required uint32 node_index = 2;

   // Leg quantity ratio, signed decimal, number of leg contracts to buy(positive) or sell(negative). Must be integer for an aggregation.
   required double qty_ratio = 3;

   // Leg price calculation ratio, signed decimal, coefficient in strategy price formula before the leg contract.
   // Same as qty_ratio if omitted.
   optional double price_ratio = 4;

   // Price offset for this leg (correct price format), only specified for legs of an aggregation or a multiplicative strategy.
   // 0 is default.
   optional double price_offset = 5;
}

// Defines a strategy nested inside a parent strategy.
message NestedStrategy
{
   // Nested strategy definition.
   required StrategyDefinition definition = 1;

   // Quantity ratio, signed decimal, number of leg contracts to buy(positive) or sell(negative).
   // Default is 1.
   optional double qty_ratio = 2;

   // Leg price calculation ratio, signed decimal, coefficient in strategy price formula.
   // Same as qty_ratio if omitted.
   optional double price_ratio = 3;
}

// Child node definition within the parent strategy tree. Can be either a resolved contract (leg) or a nested strategy.
message StrategyNodeDefinition
{
   // Operation on a node of the synthetic strategy.
   // Associating an operation with a node allows using different operations, e.g. multiplication and subtraction,
   // without introducing intermediate StrategyDefinition entities.
   // MUL and DIV cannot be mixed with SUM within the same StrategyDefinition.node_definition array.
   // i.e. node1 / node2 * node3 is allowed, but node1 / node2 + node3 is not.
   enum NodeOperation
   {
      // Add the quantity and the price.
      SUM = 1;

      // Add the quantity but multiply the price.
      MUL = 2;

      // Subtract the quantity but divide the price.
      DIV = 3;
   }

   // Specified node operation, one of NodeOperation enums, the default is SUM.
   optional uint32 node_operation = 2;

   // Leg definition, if the node is a resolved contract.
   optional LegDefinition leg = 3;

   // Nested strategy, mutually exclusive with 'leg' attribute.
   optional NestedStrategy nested_strategy = 4;
}

// Describes tick size and value, and the range of prices they apply in.
message TickSizeByPrice
{
   // Size or a single market tick in correct price format.
   required double tick_size = 1;
   
   // Contract tick money value in the contract's currency.
   // Zero if not applicable (e.g. for indexes).
   required double tick_value = 2;
   
   // The tick size and value apply from this price (inclusive) and upper, to the next TickSizeByPrice.minimum_price, if any.
   // The price is in correct price format.
   required double minimum_price = 3;
}

// Describes tick size and value applied within some range of dates.
message TickSizeByDateTillExpiration
{
   // Id of the record.  Starts from 0.  The record with id of 0 applies immediately before contract expiration, id of 1
   // applies before 0th, etc.
   required uint32 id = 1;

   // Size or a single market tick in correct price format.
   required double tick_size = 2;
   
   // Contract tick money value in the contract's currency.
   // Zero if not applicable (e.g. for indexes).
   required double tick_value = 3;
}

message ContractMetadata
{
   // Server assigned ID for a contract, it is not the same across sessions.
   required uint32 contract_id = 1;

   // Full contract symbol.
   required string contract_symbol = 2;

   // Scale to convert prices from this protocol to correct prices
   // (correctPrice = price * correctPriceScale).
   required double correct_price_scale = 3; 

   // Display Price Scale is a number that defines conversion of float correct price to
   // a 'native' integer display format and back
   // Below is the table of possible scale values
   // -------------------------------------------------------
   // | Scale |       Name            |    Description      |
   // -------------------------------------------------------
   // | 0     |One                     |Don't scale         |
   // | 1     |TenMinusOne             |Divide by 10        |
   // | 2     |TenMinusTwo             |Divide by 100       |
   // | 3     |TenMinusThree           |Divide by 1000      |
   // | 4     |TenMinusFour            |Divide by 10000     |
   // | 5     |TenMinusFive            |Divide by 100000    |
   // | 6     |TenMinusSix             |Divide by 1000000   |
   // | 7     |TenMinusSeven           |Divide by 10000000  |
   // | 8     |TenMinusEight           |Divide by 100000000 |
   // | 9     |TenMinusNine            |Divide by 1000000000|
   // | 10    |TenMinusTen             |Divide by 10^10     |
   // | 11    |TenMinusEleven          |Divide by 10^11     |
   // | 12    |TenMinusTwelve          |Divide by 10^12     |
   // | 13    |TenMinusThirteen        |Divide by 10^13     |
   // | 14    |TenMinusFourteen        |Divide by 10^14     |
   // | 15    |TenMinusFifteen         |Divide by 10^15     |
   // | 101   |Halves                  |Divide by 2         |
   // | 102   |Fourths                 |Divide by 4         |
   // | 103   |Eighths                 |Divide by 8         |
   // | 104   |Sixteenths              |Divide by 16        |
   // | 105   |ThirtySeconds           |Divide by 32        |
   // | 106   |SixtyFourths            |Divide by 64        |
   // | 107   |OneHundredTwentyEighths |Divide by 128       |
   // | 108   |TwoHundredFiftySixths   |Divide by 256       |
   // | 109   |FiveHundredTwelths      |Divide by 512       |
   // | 110   |OneThousandTwentyFourths|Divide by 1024      |
   // | 201   |HalfThirtySeconds       |Similar to 64ths    |
   // | 202   |QuarterThirtySeconds    |Similar to 128ths   |
   // | 203   |EighthThirtySeconds     |Similar to 256ths   |
   // | 204   |HalfSixtyFourths        |Similar to 128ths   |
   // | 205   |QuarterSixtyFourths     |Similar to 256ths   |
   // -------------------------------------------------------
   required uint32 display_price_scale = 4;

   // Contract description.
   required string description = 5;

   // Contract display name.
   required string title = 6;

   // Size or a single market tick in correct price format.
   required double tick_size = 7;

   // Contract currency code (ISO 4217 based).
   // Empty string if not applicable (e.g. for indexes).
   required string currency = 8;

   // Contract tick money value in the contract's currency.
   // Zero if not applicable (e.g. for indexes).
   required double tick_value = 9;

   // CFI code (Classification of Financial Instruments, ISO 10962).
   required string cfi_code = 10;

   // True if this contract is the most active one for derivatives.
   optional bool is_most_active = 11;

   // Contract trading date for derivatives
   // (local exchange date in time format, use date part only).
   optional sint64 last_trading_date = 12;

   // Contract first notice date
   // (local exchange date in time format, use date part only).
   optional sint64 first_notice_date = 13;

   // Underlying contract symbol (e.g. for options).
   optional string underlying_contract_symbol = 14;

   // Margin style (for options).
   enum MarginStyle
   {
      // The premium is paid on exercise/ expiry (position is included to OTE calculation).
      FUTURE = 1;

      // Premium is subtracted from account balance when order is filled (position is included to MVO/UPL calculation).
      PREMIUM = 2;
   }
   // This field is associated with MarginStyle enum type.
   optional uint32 margin_style = 15;

   // Name of a group of contracts that share the same properties (e.g. commodity name for futures and options)
   required string instrument_group_name = 16;

   // ID of a session information this contract is related to.
   required sint32 session_info_id = 17;

   // Market segment MIC (ISO 10383) of the contract (if available).
   optional string mic = 18;

   // if user is allowed to receive only delayed data of the contract 
   // then this parameter is set to the delay value in milliseconds.
   optional sint64 delay = 20;
   
   // instrument group name without the prefix
   required string short_instrument_group_name = 21;
   
   // description of the instrument group
   required string instrument_group_description = 22;

   // Variable tick size by contract price (if available for the contract)
   // If variable tick sizes by contract price are available, tick_size and tick_value specify the minimal tick size
   // and value among these.
   // Only one of tick_sizes_by_price and tick_sizes_by_dte can be specified.
   repeated TickSizeByPrice tick_sizes_by_price = 23;

   // Variable tick size by date till expiration (if available for the contract).  Sorted by id in ascending order.
   // If variable tick sizes by DTE are available, tick_size and tick_value specify the tick size and value applicable at 
   // the moment of symbol resolution.
   // Only one of tick_sizes_by_price and tick_sizes_by_dte can be specified.
   repeated TickSizeByDateTillExpiration tick_sizes_by_dte = 24;

   // Specifies which rule of TickSizeByDateTillExpiration applies now.
   optional uint32 tick_sizes_by_dte_id = 25;

   // Option strike display value.
   optional sint32 strike = 26;

   // Option strike price value (directly in correct format).
   optional double strike_price = 27;

   // Dialect of the contract symbol.
   // 0 - CQG dialect.
   optional string dialect_id = 28;

   // Two-letter exchange country code (ISO 3166-1 alpha 2).
   required string country_code = 29;

   // Strategy definition if the contract is of a synthetic or a user defined strategy.
   optional StrategyDefinition strategy_definition = 30;

   // The deliverable quantity of commodities or financial instruments underlying contract.
   // E.g. "1,000 U.S. Barrels (42,000) Gallons", "125,000 Euro"
   optional string contract_size = 31;
}

////------------------------------------------
//// Information Requests and Reports

// Request for information.
// There must be only one request type (e.g. accountsRequest and lastStatementBalancesRequest can not be sent at the same time).
message InformationRequest
{
   // ID of a request and optional subscription that should be unique enough to match responses and updates with corresponding requests.
   required uint32 id = 1;

   // If set to true then corresponding reports are also sent when requested information is changed during the session,
   // if set to false then subscription is dropped,
   // if omitted then data is returned without changing subscription status.
   optional bool subscribe = 2;

   // Request for authorized accounts for trading.
   // Only one subscription is possible.
   // Requests rate is limited, 100 per 24 hours by default.
   // Requests are accepted only if the user is not subscribed and there is no pending request for this information at the moment.
   optional AccountsRequest accounts_request = 3;

   // Request symbol resolution with optional subscription.
   // Requests rate is limited, 10000 per 24 hours by default.
   // NOTE: subscription is essential to follow active contract switching.
   optional SymbolResolutionRequest symbol_resolution_request = 4;

   // Request for balances from the last statement for all authorized accounts.
   // Only one subscription is possible.
   // Requests rate is limited, 100 per 24 hours by default.
   // Requests are accepted only if the user is not subscribed and there is no pending request for this information at the moment.
   optional LastStatementBalancesRequest last_statement_balances_request = 5;

   // Request for currency rates for all brokerages user's accounts belong to.
   // Only one subscription is possible.
   // Requests rate is limited, 100 per 24 hours by default.
   // Requests are accepted only if the user is not subscribed and there is no pending request for this information at the moment.
   optional CurrencyRatesRequest currency_rates_request = 6;

   // Request for session information.
   // Number of simultaneous requests in processing is limited, 10 by default.
   // Number of simultaneous session information update subscriptions is limited, 200 by default.
   // Requests are accepted only if the user is not subscribed for this information at the moment.
   optional SessionInformationRequest session_information_request = 7;

   // Request for a list of historical orders (including all transactions) according to a search criteria.
   // Number of simultaneous requests in processing is limited, 1 by default.
   // The request depth is limited, 30 days by default.
   // Subscription is not supported for this request.
   optional HistoricalOrdersRequest historical_orders_request = 13;

   // Request a list of child symbols for an underlying contract.
   // Number of simultaneous requests in processing is limited, 5 by default.
   // Number of simultaneous update subscriptions is limited, 100 by default.
   optional SymbolsByUnderlyingRequest symbols_by_underlying_request = 14;

   // Request a list of child symbols for a higher level symbol.
   // Number of simultaneous requests in processing is limited, 5 by default.
   // Number of simultaneous update subscriptions is limited, 100 by default.
   optional ChildSymbolsRequest child_symbols_request = 15;

   // Request at-the-money strike for the option maturity.
   // Number of simultaneous requests in processing is limited, 5 by default.
   // Number of simultaneous update subscriptions is limited, 100 by default.
   optional AtTheMoneyStrikeRequest at_the_money_strike_request = 16;

   // Request strategy definition with no subscription.
   // Requests rate is limited, 10000 per 24 hours by default.
   optional StrategyDefinitionRequest strategy_definition_request = 17;

   // Request for session timerange information.
   // Number of simultaneous requests in processing is limited, 10 by default.
   // The request range is limited. 1 year/1000 sessions by default.
   // Subsription is NOT supported for this request, so subscribe flag will be ignored.
   optional SessionTimeRangeRequest session_timerange_request = 18;

   // Request for trading day timerange information.
   // Number of simultaneous requests in processing is limited, 10 by default.
   // The request range is limited. 1 year/250 trading days by default.
   // Subsription is NOT supported for this request, so subscribe flag will be ignored.
   optional TradingDayTimeRangeRequest trading_day_timerange_request = 19;
}

// Report with requested information and subscription updates.
// It will contain only one report type at the same time (related to id).
message InformationReport
{
   // Report ID is equal to a corresponding request and subscription ID.
   required uint32 id = 1;

   // True means that requested data is complete at the moment, false means more report messages are expected for completeness.
   optional bool is_report_complete = 2 [default = true];

   // Optional status code for a request or subscription, status is only sent for initial status and status changes.
   enum StatusCode
   {
      /// success codes  (0 - 99)
      // Request is processed without subscription (subscription was not requested).
      SUCCESS = 0;

      // Request is processed and subscription is established.
      SUBSCRIBED = 1;

      // Subscription is dropped by a client request.
      DROPPED = 2;

      // Unsolicited information update because of subscription.
      UPDATE = 3;

      // Currently subscription is disconnect because of communication issues
      // NOTE: Clients should not resubscribe in this case, the server will restore subscription with 
      // sending SUBSCRIBED status once communication issues are resolved
      DISCONNECTED = 4;

      /// failure codes (100+), subscription (if any) is dropped in case of failure.
      // General failure.
      FAILURE = 101;

      // Requested information is not found.
      NOT_FOUND = 104; 

      // The limit of the request number has been violated.
      REQUEST_LIMIT_VIOLATION = 105;
   }
   // This field is associated with StatusCode enum type.
   required uint32 status_code = 3;

   // Possible details of status or failure.
   optional string text_message = 4;

   // Report with trading accounts.
   optional AccountsReport accounts_report = 5;

   // Resolved symbol initial information or update.
   optional SymbolResolutionReport symbol_resolution_report = 6;

   // Report with balances from the last statement for all authorized accounts.
   optional LastStatementBalancesReport last_statement_balances_report = 7;

   // Report with currency rates per brokerage.
   optional CurrencyRatesReport currency_rates_report = 8;

   // Report with session information.
   optional SessionInformationReport session_information_report = 9;

   // Report with a list of historical orders according to specified parameters.
   optional HistoricalOrdersReport historical_orders_report = 15;

   // Report with a list of symbols for an underlying contract.
   optional SymbolsByUnderlyingReport symbols_by_underlying_report = 16;

   // Report with a list of child symbols.
   optional ChildSymbolsReport child_symbols_report = 17;

   // Report with at-the-money strikes.
   optional AtTheMoneyStrikeReport at_the_money_strike_report = 18;

   // Report with the defined strategy metadata
   optional StrategyDefinitionReport strategy_definition_report = 19;


   // Report with session timerange information
   optional SessionTimeRangeReport session_timerange_report = 20;

   // Report with trading day timerange information
   optional TradingDayTimeRangeReport trading_day_timerange_report = 21;
}

// Request for a list of accounts this user is authorized to use and/ or monitor, empty message.
message AccountsRequest
{
}

// Response with a list of authorized accounts grouped by brokerage firms and internal sales series (account groups),
// the same account can not belong to more than one account group.
message AccountsReport
{
   // List or brokerages with accounts the user works with.
   repeated Brokerage brokerage = 1;
}

// List of brokerage accounts.
message Brokerage
{
   // Brokerage firm ID in CQG trade routing system.
   required uint32 id = 1;

   // Brokerage firm name.
   required string name = 2;

   // List of sales series.
   repeated SalesSeries sales_series = 3;
}

// List of accounts in a sales series group.
message SalesSeries
{
   // Sales series number in CQG trade routing system.
   required string number = 1;

   // Sales series name.
   required string name = 2;

   // List of accounts.
   repeated Account account = 3;
}

// Trade routing account data.
message Account
{
   // Account ID in CQG trade routing system.
   required sint32 account_id = 1;

   // Account ID in Brokerage Firm.
   required string brokerage_account_id = 2;

   // Account name in CQG trade routing system.
   required string name = 3;

   // Last statement date for this account
   // (brokerage local date in time format, use date part only).
   required sint64 last_statement_date = 4;

   // True if user can only monitor this account without trading.
   optional bool is_view_only = 5;

   // True if user was unauthorized and is not able to use/ see this account anymore.
   optional bool is_unauthorized = 6;

   // ID of cluster of common properties the account belongs to (if any).
   optional sint64 account_cluster_id = 7;
}

// Request to resolve a symbol pattern or specific symbol identifier to a specific contract with optional subscription for meta-data updates.
// Symbol resolution rules:
//   a) If the requested symbol points to a symbol prefix rather than a specific contract then it is resolved into the most active contract for
//      this symbol prefix (e.g. 'EP' is resolved to 'EPU3').
//      The update is sent when an active contract is changed (e.g. the update might contain the following 'EPZ3')
//   b) If the requested symbol points to a specific contract that is expired already then status code NOT_FOUND is returned in InformationReport.
//   c) If the requested symbol points to a specific contract that is tradable right now then it is resolved to itself. Update is sent only when
//      meta-data for such contract is changed or expired. In case of expiration SymbolResolutionReport is returned with 'deleted' field set to True.
//   d) If requested symbol points to an option instrument without specific month and strike it is resolved to the lead (first non-spot) month
//      of the underlying future or its own front month if the underlying contract is not a future (e.g. 'C.EP' is resolved to 'C.EPU131600'). 
//      Update is sent only when the resolved option contract is expired (strike is not updated to follow underlying contract market price).
//   e) If requested symbol is a symbol prefix that follows '?N' or '??N' (where N is number, e.g. EP?2) then it is resolved to
//      Nth nearest contract.
//      N = 1 means 'front' contract, N = 2 means the nearest contract that follows the front, etc.
//      '?' and '??' are different for futures only and '?' means Nth nearest regular future and '??' means Nth nearest spot or regular future.
//      Update is sent when the front contract expired and replaced with the following contract (relative position change).
//      N = 0 is a special case that means 'most active' contract which works the same way as (a)
// NOTE: Available and active contract lists are updated within 24 hours of an expiring contract's final trading session.
//       Meta-data updates for affected contracts, when a subscription is present, are sent when the list updates occur.
//       Initial resolution requests use the same lists, so the best way to avoid inconsistency and unnecessary server load is to subscribe
//       and process updates when notified.
message SymbolResolutionRequest
{
   // Symbol pattern to resolve.
   required string symbol = 1;
}

// Symbol resolution result or update.
message SymbolResolutionReport
{
   // Resolved contract meta-data.
   required ContractMetadata contract_metadata = 1;

   // Contract is expired (used for updates).
   optional bool deleted = 2;
}

// Request for balances from the last statement for all authorized accounts.
message LastStatementBalancesRequest
{
}

// Report with balances from the last statement for all authorized accounts,
// they will be sent as a response to a corresponding request
// and after each statement processing (if subscribed).
message LastStatementBalancesReport
{
   repeated Balance balance = 1;
}

// Balance record for one of the accounts and one of the currencies (id is used as a key for updates).
// Values like OTE, UPL and MVO are from statements and won't be updated in real time but after each next statement.
// Money related values are in the specified currency.
// NOTE: There could be more then one balance for one account and one currency. 
//       Not all values for a balance record are provided by all statements, it is up to Brokerage to include such values and only 
//       currency and ending cash balance are required to be valid.
message Balance
{
   // Surrogate id as a key for updates.
   required sint32 id = 1;

   // Account of this balance record.
   required sint32 account_id = 2;

   // Statement date this positions is related.
   required sint64 statement_date = 3;

   // Currency code (ISO 4217 based).
   required string currency = 4;

   // Ending Cash Balance.
   required double balance = 5;

   // Total Account Value.
   required double total_value = 6;

   // Open Trade Equity for Futures.
   required double ote = 7;

   // Unrealized profit-loss.
   required double upl = 8;

   // Market Value of options.
   required double mvo = 9;

   // Cash Excess.
   required double cash_excess = 10;

   // Collateral on Deposit.
   required double collateral = 11;

   // Initial Margin Requirements.
   required double initial_margin = 12;
}

// Request for currency rates for all brokerages user's accounts belong to.
message CurrencyRatesRequest
{
}

// Report with currency rates per brokerage.
// It will be sent as a response to a corresponding request
// and after each statement processing (if subscribed).
message CurrencyRatesReport
{
   // List of rates per brokerage the user is authorized to.
   repeated BrokerageCurrencyRates brokerage_currency_rates = 1;
}

// Currency rates of one brokerage.
message BrokerageCurrencyRates
{
   // Brokerage ID.
   required uint32 brokerage_id = 1;

   // Master currency code to which rates are provided (ISO 4217 based).
   required string master_currency = 2;

   // Statement date.
   required sint64 statement_date = 3;

   // List of brokerage rates.
   repeated CurrencyRate currency_rate = 4;
}

// Rate of one currency to a master currency for the brokerage.
message CurrencyRate
{
   // Currency code (ISO 4217 based).
   required string currency = 2;

   // Exchange rate.
   required double rate = 3;
}

// Request for session information per instrument group.
message SessionInformationRequest
{
   // ID of a session information from contract meta-data.
   required sint32 session_info_id = 1;

   // UTC time from which session information is requested (e.g. if historical session times are necessary)
   // Current time is used by default.
   optional sint64 from_utc_time = 2;

   // UTC time up to which session information is requested (e.g. if future session times are necessary)
   // Current time is used by default. This field must not be used with subscriptions.
   optional sint64 to_utc_time = 3;
}

// Report with session information.
message SessionInformationReport
{
   // Session information ID.
   required sint32 session_info_id = 1;

   // List of session segment records.
   repeated SessionSegment session_segment = 2;
}

// Session segment record.
message SessionSegment
{
   // Session segment ID useful for updates.
   required sint32 session_segment_id = 1;

   // Session group is deleted (used for updates).
   optional bool deleted = 2;

   // UTC time from which this session information is effective (inclusive).
   // It is omitted if this session information was the same since Instrument group was introduced.
   optional sint64 from_utc_time = 3;

   // UTC time up to which this session information is effective (exclusive).
   // It is omitted if this session information is not planned yet to be changed.
   optional sint64 to_utc_time = 4;

   // Schedule for all sessions.
   repeated SessionSchedule session_schedule = 5;

   // Trading day schedule.
   repeated TradingDay trading_day = 6;

   // Daily holidays. May have some sessions interday, but daily bar is not created.
   repeated SessionHoliday daily_holiday = 7;
}

// Session schedule.
message SessionSchedule
{
   // Session name.
   required string name = 1;

   // List of session times per day of week.
   repeated SessionDay session_day = 2;

   // List of exchange specific dates when this session is closed.
   repeated SessionHoliday session_holiday = 3;

   // True if this is a primary session.
   optional bool is_primary = 4;
}

// Days of week enumeration. 
enum DayOfWeek
{
   Sunday = 0;
   Monday = 1; 
   Tuesday = 2; 
   Wednesday = 3;
   Thursday = 4;
   Friday = 5;
   Saturday = 6;
}

// Trading day schedule.
message TradingDay
{
   // Days of week list with the same day schedule.
   repeated DayOfWeek day_of_week = 1;

   // Trading day start offset in milliseconds from 00:00 UTC.
   optional sint64 start_offset = 2;
}

// Session times per day of week.
// All time offsets are in milliseconds from 00:00 UTC time of a specific date that corresponds to specific day of week.
// Offset values are optional and can be positive and negative
// (e.g. session can be completely 'pre-open' so only pre_open_offset and post_close_offset values are set).
// NOTE: Session times may not match exact exchange schedule especially if exchange have dynamic times
// (e.g. session starts after publishing a settlement, after underlying contract trade, etc.) 
// or if exchange sends market data outside of session boundaries (e.g. late trades)
message SessionDay
{
   // Days of week list with the same day schedule.
   repeated DayOfWeek day_of_week = 1;

   // Session pre-open time offset.
   optional sint64 pre_open_offset = 2;

   // Session open time offset.
   optional sint64 open_offset = 3;

   // Session close time offset.
   optional sint64 close_offset = 4;

   // Session post-close time offset.
   optional sint64 post_close_offset = 5;
}

// Session holiday record.
message SessionHoliday
{
   // Date of a holiday.
   required sint64 holiday_date = 1;

   // Name of a holiday.
   required string holiday_name = 2;
}

// Request a list of symbols (options) by an underlying contract
message SymbolsByUnderlyingRequest
{
   required uint32 underlying_contract_id = 1;
}

// Report with a list of symbols.
// When the list is updated by a subscribtion 
// (e.g. some option maturity is expired or a new one appears)
// the list includes only new or deleted symbols.
message SymbolsByUnderlyingReport
{
   // List of related symbols (option maturities without strikes)
   repeated Symbol symbol = 1;
}

// Request a list of child symbols for a higher level symbol.
message ChildSymbolsRequest
{
   // Can be either id of the parent symbol or instrument group's name (for futures only, e.g. 'F.US.EP').
   required string parent_symbol_id = 1;
}

// Report with a list of child symbols.
message ChildSymbolsReport
{
   // List of child symbols.
   repeated Symbol symbol = 1;
}

// Request at-the-money strike for the option maturity
message AtTheMoneyStrikeRequest
{
   // Option maturity symbol id representing the parent symbol for the option strike list of the same underlying and maturity period (see Symbol.id).
   required string option_maturity_symbol_id = 1;
}

// Report with at-the-money strikes.
message AtTheMoneyStrikeReport
{
   // Option at-the-money strike.
   // It is omitted if at-the-money strike cannot be calculated at the moment (e.g. due to lack of real time data).
   optional sint32 strike = 1;
}

// Request for session open/close times.
message SessionTimeRangeRequest
{
   // ID of a session information from contract meta-data.
   required sint32 session_info_id = 1;

   // Exactly two of the next three fields have to be set:
   // UTC time of start of the time range to get information for.
   // Sessions with post-close time > from_utc_time are returned.
   optional sint64 from_utc_time = 2;

   // UTC time of end of the time range to get information for.
   // Sessions with pre-open time < to_utc_time are returned.
   optional sint64 to_utc_time = 3;

   // Number of session timeranges to return.
   // If used with from_utc_time then it is the number of timeranges to return starting from that time.
   // If used with to_utc_time then it is the number of timeranges to return preceding that time.
   optional uint32 count = 4;
}

// This may come in multiple chunks if many items are reported.
message SessionTimeRangeReport
{
   // Session open/close times.
   repeated SessionTimeRange session_time_ranges = 1;

   // Request was done for the range that was too long, so it was truncated.
   optional bool truncated = 2;
}

// Session open/close times and trading day date.
message SessionTimeRange
{
   // UTC time of session pre-open.
   required sint64 pre_open_utc_time = 1;

   // UTC time of session open.
   required sint64 open_utc_time = 2;

   // UTC time of session close.
   required sint64 close_utc_time = 3;

   // UTC time of session post close.
   required sint64 post_close_utc_time = 4;

   // Trading date the session belongs to, local to exchange, time part is not used (set to 00:00).
   required sint64 trade_date = 5;

   // Session name.
   required string session_name = 6;
}

// Request for trading day open/close times.
message TradingDayTimeRangeRequest
{
   // ID of a session information from contract meta-data.
   required sint32 session_info_id = 1;

   // True if holidays should be included in the response.
   optional bool include_holidays  = 2;

   // Exactly two of the next three fields have to be set:
   // UTC time of start of the time range to get information for.
   // Trading days with end time > from_utc_time are returned.
   optional sint64 from_utc_time = 3;

   // UTC time of end of the time range to get information for.
   // Trading days with start time < to_utc_time are returned.
   optional sint64 to_utc_time = 4;

   // Number of trading day timeranges to return.
   // If used with from_utc_time then it is the number of timeranges to return starting from that time.
   // If used with to_utc_time then it is the number of timeranges to return preceding that time.
   optional uint32 count = 5;
}

// This may come in multiple chunks if many items are reported.
message TradingDayTimeRangeReport
{
   // Trading day start/end times.
   repeated TradingDayTimeRange trading_day_time_ranges = 1;

   // Request was done for the range that was too long, so it was truncated.
   optional bool truncated = 2;
}

// Trading day start/end times and date.
message TradingDayTimeRange
{
   // Trading date, local to exchange, time part is not used (set to 00:00).
   required sint64 trade_date = 1;

   // The next two fields are not present for holidays,
   // because there’s no trading day for these dates, hence no start and end times.
   // UTC time of trading day start (first session pre-Open time).
   optional sint64 start_utc_time = 2;

   // UTC time of trading day end (last session post-Close time).
   optional sint64 end_utc_time = 3;
}

// Symbol structure
message Symbol
{
   // Symbol Identifier.
   required string id = 1;

   // Symbol readable name.
   required string name = 2;

   // Symbol description.
   required string description = 3;

   // CFI code (Classification of Financial Instruments, ISO 10962) if appropriate.
   optional string cfi_code = 4;

   // True if this symbol has child symbols.
   optional bool has_child_symbols = 5;

   // Contract meta-data if a symbol is a specific contract
   optional ContractMetadata contract_metadata = 6;

   // Deleted flag is used in updates when the symbol is removed (e.g. expired)
   optional bool deleted = 7;

   // Last trading date for derivatives if applicable.
   // (local exchange date in time format, use date part only).
   optional sint64 last_trading_date = 8;
   
   // Month letter and 2-digit year identifying the expiration month of the symbol (or its underlying in case of options).
   // Doesn't depend on dialect.
   // Month and corresponding letter:
   // January   F
   // February  G
   // March     H
   // April     J
   // May       K
   // June      M
   // July      N
   // August    Q
   // September U
   // October   V
   // November  X
   // December  Z
   optional string maturity_month_year = 9;
   
   // Name of a group of symbols that share the same properties (e.g. commodity name for futures and options)
   required string instrument_group_name = 10;
}

// Request to define a strategy as a contract
message StrategyDefinitionRequest
{
   // Strategy to define.
   required StrategyDefinition strategy_definition = 1;
}

// Report of the contract metadata assigned to the strategy.
message StrategyDefinitionReport
{
   // Assigned strategy metadata.
   required ContractMetadata contract_metadata = 1;
}

////------------------------------------------
//// Trade Routing messaging


// Subscription to trade routing data and notifications about trading information updates.
// Client can be subscribed to several publications.
// If some account is subscribed by several publications then client will receive a separate snapshot per subscription
// but one real time update with a list of subscriptions.
message TradeSubscription
{
   // ID of a subscription that should be unique enough to match responses and updates with corresponding requests.
   required uint32 id = 1;

   // Scope of the subscription (provide a list).
   enum SubscriptionScope
   {
      // Subscribe to order updates.
      ORDERS = 1;

      // Subscribe to open positions and matched trades updates.
      POSITIONS = 2;

      // Subscribe to collateral updates (current margin and purchasing power).
      COLLATERAL = 3;
   }
   // This field is associated with SubscriptionScope enum type.
   repeated uint32 subscription_scope = 2;

   // Type of the publication to subscribe.
   enum PublicationType
   {
      // Subscribe to a single account.
      ACCOUNT = 1;

      // Subscribe to all accounts of a specific sales series.
      SALES_SERIES = 2;

      // Subscribe to all accounts of a specific brokerage.
      BROKERAGE = 3;

      // Subscribe to all accounts this user is authorized for (default).
      ALL_AUTHORIZED = 4;
   }
   // This field is associated with PublicationType enum type.
   optional uint32 publication_type = 3;

   // Account ID when publicationType = ACCOUNT.
   optional uint32 account_id = 4;

   // Sales series number when publicationType = SALES_SERIES.
   // Note: sales_series_number might be not enough to find specific sales series,
   // so brokerage_id is needed to be specified as well.
   optional string sales_series_number = 5;

   // Brokerage ID when publicationType = BROKERAGE or SALES_SERIES.
   optional uint32 brokerage_id = 6;

   // True to subscribe, false to unsubscribe (only id value is used to unsubscribe).
   required bool subscribe = 7;

   // Optionally limit request to receive information about orders that were updated/ added after specified server related time (inclusive).
   // It is used to reduce amount of information necessary to send after re-connection.
   // Client should set this time equal to the last received order status time ('status_utc_time' field) in UTC to avoid gaps and
   // be ready for duplicates that have to be detected by corresponding IDs.
   // Note: use last_order_update_utc_timestamp field instead.
   optional sint64 last_order_update_utc_time = 8 [deprecated = true];

   // Optionally limit request to receive information about orders that were updated/ added after specified server related time (inclusive).
   // It is used to reduce amount of information necessary to send after re-connection.
   // Client should set this time equal to the last received order status time ('status_utc_time' field) in UTC to avoid gaps and
   // be ready for duplicates that have to be detected by corresponding IDs.
   // If specified it's used instead of last_order_update_utc_time field.
   optional google.protobuf.Timestamp last_order_update_utc_timestamp = 14;

   // True means sending only real time data and skip sending an initial orders snapshot, send initial snapshot otherwise.
   // NOTE: do not set this attribute after restoring session since some events might be missed to be delivered,
   // use last_order_update_utc_time instead.
   optional bool skip_orders_snapshot = 9;

   // True means sending only FCM confirmed positions and their updates (if subscribed)
   // without matching with current day fills, send matched net positions otherwise.
   optional bool confirmed_positions_only = 10;

   // Positions matching algorithm (for position subscription).
   enum MatchingAlgorithm
   {
      // First In, First Out. The first order filled is the first order offset when an order on the opposite side of the market is executed.
      FIFO = 1;

      // High Buy, High Sell. The highest buy is matched with the highest sell.
      HBHS = 2;

      // Last In, First Out. The last order filled is the first order offset when an order on the opposite side of the market is executed.
      LIFO = 3;
   }
   // This field is associated with MatchingAlgorithm enum type.
   // FIFO is used if omitted.
   optional uint32 matching_algorithm = 11;

   // If true or omitted then intraday trades are matched first and then intraday leftover is matched against previous close positions.
   // If false then previous day open positions and intraday fills are matched in a single pass.
   optional bool match_intraday_first = 12;

   // This field is associated with MatchingAlgorithm enum type.
   // Historical positions Matching algorithm. The same as matching_algorithm if omitted.
   // It is ignored if match_intraday_first is false.
   optional uint32 historical_matching_algorithm = 13;

}

// Server status for a trade subscription.
// It is sent before or along with a snapshot of initial status information.
message TradeSubscriptionStatus
{
   // Subscription Id this result is sent for.
   required uint32 id = 1;

   // Possible result codes.
   enum StatusCode
   {
      // success codes (0 - 99)
      SUCCESS = 0;

      // Currently subscription is [partially] disconnect because of communication issues
      // NOTE: Clients should not resubscribe in this case, the server will restore subscription with 
      // sending SUCCESS status once communication issues are resolved following with all necessary data updates
      DISCONNECTED = 1;

      // failure codes (100+)
      FAILURE = 101;

      // The limit of the request number has been violated.
      REQUEST_LIMIT_VIOLATION = 102;

      // Unknown or ambiguous account, sales series number, or brokerage id in the subscription
      INVALID_PUBLICATION_ID = 103;
   }
   // Subscription result.
   // This field is associated with StatusCode enum type.
   required uint32 status_code = 2;

   // Optional details.
   optional string text_message = 3;
}

// Indicator that a snapshot of requested information is delivered and corresponding data is complete.
message TradeSnapshotCompletion
{
   // ID of a corresponding trade subscription.
   required uint32 subscription_id = 1;

   // List of subscription scopes whose snapshots are completed.
   // Completion message for one scope is sent only once but they can be combined
   // (e.g. one completion message might come for ORDERS and another one later for POSITIONS and COLLATERAL).
   // This field is associated with TradeSubscription.SubscriptionScope enum type.
   repeated uint32 subscription_scope = 2;
}

// MiFID algorithm ID type.
enum MiFIDAlgorithmIdType
{
   // External MiFID Algo ID, an explicit value to be sent as-is to the execution system.
   // Non-CQG WebAPI clients should always use this type.
   EXTERNAL_MIFID_ALGO_ID = 1;

   // CQG internal MiFID Algo ID.
   CQG_MIFID_ALGO_ID = 2;
}

// One of the order related requests. There must be only one optional order submessage specified per request.
// E.g NewOrder, but not NewOrder and CancelOrder.
message OrderRequest
{
   // ID of a request that should be unique enough to match with possible OrderRequestReject.
   required uint32 request_id = 1;

   // New order request (place order).
   optional NewOrder new_order = 2;

   // Modify order request.
   optional ModifyOrder modify_order = 3;

   // Cancel order request.
   optional CancelOrder cancel_order = 4;

   // Cancel all orders request.
   optional CancelAllOrders cancel_all_orders = 14;

   // Suspend (park) order.
   optional SuspendOrder suspend_order = 10;

   // Activate suspended (parked) order.
   optional ActivateOrder activate_order = 5;

   // Modify order's user attributes.
   optional ModifyUserAttributes modify_user_attributes = 6;

   // New compound order request (place compound order).
   optional NewCompoundOrder new_compound_order = 8;

   // Synthetic hangup liquidation with a MKT order.
   optional SyntheticLiquidate synthetic_liquidate = 11;

   // Synthetic hangup liquidation with a LMT order.
   optional SyntheticScratch synthetic_scratch = 12;

   // Modify an order to get an immediate fill.
   optional GoMarket go_market = 13;

   // Username of the user on whose behalf the order request is being sent.
   optional string on_behalf_of_user = 7;
   
   // Regulatory Algorithm ID for client algorithm associated with this order, if any.
   // This field is applicable only for exchanges that use it, e.g. Eurex.
   // TransactionStatus message echoes back the value from the latest order request
   optional uint32 client_regulatory_algorithm_id = 9;

   // MiFID algorithm ID for this order, contents depend on mifid_algorithm_id_type.
   // Provide only when the order must have an algorithm as Execution Within Firm under MiFID II definitions.
   optional string mifid_algorithm_id = 15;

   // The type of mifid_algorithm_id supplied. One of MiFIDAlgorithmIdType enum.
   optional uint32 mifid_algorithm_id_type = 16;

   // True instructs server to send this order as Execution Within Firm=CLIENT/NORE
   // rather than the user's server-side configured trader short code.
   optional bool override_execution_within_firm_with_nore = 17 [default = false];
}

// Low-level order request reject. It is sent only if direct order status updates are impossible.
message OrderRequestReject
{
   // ID of the order request this reject corresponds to.
   required uint32 request_id = 1;

   // Reject code. The list is provided separately.
   required uint32 reject_code = 2;

   // Optional reject details message.
   optional string text_message = 3;
}

// New order request.
message NewOrder
{
   // Order to place.
   required Order order = 1;

   // True if order should be suspended (parked) and wait a separate activate request or activation time.
   optional bool suspend = 2;
}

// Trade routing order. It is used as new order request and as a part of order status updates.
message Order
{
   enum Side
   {
      // Describes purchasing side of a trade.
      BUY = 1;

      // Describes selling side of a trade.
      SELL = 2;
   }

   enum OrderType
   {
      // Market order, buy or sell by the best available opposite price.
      MKT = 1;

      // Limit order, buy or sell by price that is the same or better then specified limit price.
      LMT = 2;

      // Stop order, Order becomes a Market when market reaches order's stop price
      // (which is on opposite side of market).
      STP = 3;

      // Stop-limit order, Order becomes a Limit when market reaches order's stop price.
      STL = 4;
   }

   enum ExecInstruction
   {
      // All or None (fill order only completely).
      AON = 1;

      // Iceberg (show only part of order size).
      ICEBERG = 2;

      // Quantity triggered (aka DOM Triggered, honor additional quantity threshold for triggering).
      QT = 3;

      // Trailing order (price of the order is following market one direction by specific offset).
      TRAIL = 4;

      // Funari (Limit order becomes a Market on Close).
      FUNARI = 5;

      // Market if Touched (Limit order becomes a Market when market reaches order's limit price).
      MIT = 6;

      // Market Limit Market is a limit order that is used to place a buy order above the best offer 
      // to fill by the best offer or a sell order below the best bid to fill by the best bid.
      MLM = 7;
   }

   enum Duration
   {
      // Day order. Order is working through the current trading day only.
      DAY = 1;

      // Good Til Canceled. Order is working until canceled or until the contract is no longer available for trading.
      GTC = 2;

      // Good Til Date. Order is working until the end of the nearest trading day for the contract on 
      // or before the date specified in the order.
      GTD = 3;

      // Good Til Time. Order is working until the specified time.
      GTT = 4;

      // Fill and Kill. Immediately fill as many as possible and cancel the rest.
      FAK = 5;

      // Fill Or Kill. Immediately fill this order completely or cancel.
      FOK = 6;

      // At The Open. Buy or sell at the very beginning of the trading day.
      ATO = 7;

      // At The Close. Buy or sell at the close of the market, or as near to the closing price as possible.
      ATC = 8;
   }

   enum TrailingPeg
   {
      // Trail the best bid.
      BESTBID = 1;

      // Trail the best ask.
      BESTASK = 2;

      // Trail the last trade.
      LASTTRADE = 3;
   }

   // Id of an account that is/ was used to place an order.
   required sint32 account_id = 1;

   // Client side time when an order was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 2 [deprecated = true];

   // Client side time when an order was submitted (UTC).
   // If specified by the user it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 27;

   // Server side contract Id of the order (see ContractMetadata message).
   required uint32 contract_id = 3;

   // Client order identifier, must be unique within a single trading day for day orders and across days for multi-day orders.
   // Maximum allowed length is 64 bytes.
   required string cl_order_id = 4;

   // Order type.
   // This field is associated with OrderType enum type.
   required uint32 order_type = 5;

   // List of applicable execution instructions.
   // This field is associated with ExecInstruction enum type.
   repeated uint32 exec_instruction = 6;

   // Order duration.
   // This field is associated with Duration enum type.
   required uint32 duration = 7;

   // Date for GTD (local to exchange, date only value in time format) when the order should expire.
   optional sint64 good_thru_date = 8;

   // Order side.
   // This field is associated with Side enum type.
   required uint32 side = 9;

   // Limit price of the order (required for Limit and Stop-limit orders).
   optional sint64 limit_price = 10;

   // Stop price of the order (required for Stop and Stop-limit orders).
   optional sint64 stop_price = 11;

   // Total positive size of the order.
   required uint32 qty = 12;

   // Visible size of the order for Icebergs.
   optional uint32 visible_qty = 13;

   // Minimum visible positive size of the order
   // used for iceberg orders with 'random visible size',
   // must be < visible_qty.
   optional uint32 min_visible_qty = 14;

   // True if this is a manual order (order placed by the user direct action), automated otherwise.
   required bool is_manual = 15;

   // True if order is used for closing/ reducing a position, opening/ increasing otherwise
   // (omit this field if there is no need to be explicit).
   optional bool is_close = 16;

   // True if the order is aggressive (Fixed Income specific order modifier).
   optional bool is_aggressive = 17;

   // Maximum offset between market and limit prices for trail orders.
   optional sint32 trail_offset = 18;

   // Trailing limit peg to follow specific side of the market.
   // This field is associated with TrailingPeg enum type.
   optional uint32 trailing_peg = 19;

   // Trigger quantity (threshold) as additional stop order activation condition.
   optional uint32 trigger_qty = 20;

   // Time when order should be submitted to execution system as assigned by client (UTC).
   // Note: use activation_utc_timestamp field instead.
   optional sint64 activation_utc_time = 21 [deprecated = true];

   // Time when order should be submitted to execution system as assigned by client (UTC).
   // If specified by the user it's used instead of activation_utc_time field.
   optional google.protobuf.Timestamp activation_utc_timestamp = 28;

   // Time when order should be suspended (parked) (UTC).
   // Note: use suspension_utc_timestamp field instead.
   optional sint64 suspension_utc_time = 22 [deprecated = true];

   // Time when order should be suspended (parked) (UTC).
   // If specified by the user it's used instead of suspension_utc_time field.
   optional google.protobuf.Timestamp suspension_utc_timestamp = 29;

   // User specific attributes.
   repeated UserAttribute user_attribute = 23;

   // Date and time for GTT order (UTC) when the order should expire.
   // Note: use good_thru_utc_timestamp field instead.
   optional sint64 good_thru_utc_time = 24 [deprecated = true];

   // Date and time for GTT order (UTC) when the order should expire.
   // If specified by the user it's used instead of good_thru_utc_time field.
   optional google.protobuf.Timestamp good_thru_utc_timestamp = 30;

   // Flag used by the client for marking the user attributes checked/unchecked.
   optional bool is_user_attribute_checked = 25 [default = true];

   // Synthtetic strategy trading parameters, applicable only if contract_id designates a synthetic strategy.
   // If the parameter is not applicable for the order the default value is used.
   optional StrategyTradingParameters strategy_trading_parameters = 26;
}

// User defined attribute.
message UserAttribute
{
   // Attribute name.
   required string name = 1;

   // Attribute value (optional for modification if attribute is deleted).
   optional string value = 2;

   // True if attribute has to be deleted during modify operation.
   optional bool delete = 3;
}

// Synthetic strategy order's outright properties.
message SyntheticStrategyProperties
{
   // Synthtetic strategy trading parameters.
   optional StrategyTradingParameters strategy_trading_parameters = 1;

   // Parent synthetic order id that led to this order's (automatic) placement;
   // allows client to show the link to user.
   // Note: this is the original synthetic order's ID (OrderStatus.order_id), not affected by any modifications.
   optional string origin_order_id = 2;

   // Id of the originally placed by trader root synthetic strategy order (The same as origin_order_id for the root immediate legs).
   optional string root_order_id = 3;

   // Node index of the synthetic order (specified by root_order_id);
   // allows client to associate this order with a particular node of the synthetic strategy (either a leg or a nested strategy).
   // LegDefinition.node_index or StrategyDefinition.node_index value.
   optional uint32 node_index = 4;
}

// Modify order request, include only fields that are supposed to be modified.
message ModifyOrder
{
   // Order id assigned by server after last modification.
   required string order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;

   // This client order ID of the order to modify.
   required string orig_cl_order_id = 3;

   // Client order ID of this modify request (will become new client order Id if modify is accepted).
   // Maximum allowed length is 64 bytes.
   required string cl_order_id = 4;

   // Client side time when a modify request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 5 [deprecated = true];

   // Client side time when a modify request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 18;

   // Order size what the client wants the total size to become.
   optional uint32 qty = 6;

   // What the client wants the visible size to become.
   optional uint32 visible_qty = 7;

   // What the client wants the minimum visible size to become.
   optional uint32 min_visible_qty = 8;

   // What the client wants the limit price to become.
   optional sint64 limit_price = 9;

   // What the client wants the stop price to become.
   optional sint64 stop_price = 10;

   // What the client wants the activation time to become (UTC).
   // Note: use activation_utc_timestamp field instead.
   optional sint64 activation_utc_time = 11 [deprecated = true];

   // What the client wants the activation time to become (UTC).
   // If specified it's used instead of activation_utc_time field.
   optional google.protobuf.Timestamp activation_utc_timestamp = 19;

   // True if activation time should be removed.
   optional bool remove_activation_time = 12;

   // What the client wants the suspension time to become (UTC).
   // Note: use suspension_utc_timestamp field instead.
   optional sint64 suspension_utc_time = 13 [deprecated = true];

   // What the client wants the suspension time to become (UTC).
   // If specified it's used instead of suspension_utc_time field.
   optional google.protobuf.Timestamp suspension_utc_timestamp = 20;

   // True if suspension time should be removed.
   optional bool remove_suspension_utc_time = 14;

   // What the client wants the order duration to become.
   // This field is associated with Order.Duration enum type.
   optional uint32 duration = 15;

   // What the client wants the order expiration date to become (see Order.good_thru_date).
   optional sint64 good_thru_date = 16;

   // What the client wants the order expiration time to become (see Order.good_thru_utc_time).
   // Note: use good_thru_utc_timestamp field instead.
   optional sint64 good_thru_utc_time = 17 [deprecated = true];

   // What the client wants the order expiration time to become (see Order.good_thru_utc_timestamp).
   // If specified by the user it's used instead of good_thru_utc_time field.
   optional google.protobuf.Timestamp good_thru_utc_timestamp = 21;
}

// Cancel order request.
message CancelOrder
{
   // Order id assigned by server after last modification.
   required string order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;

   // This client order ID of the order to cancel.
   required string orig_cl_order_id = 3;

   // Client order ID of this cancel request.
   // Maximum allowed length is 64 bytes.
   required string cl_order_id = 4;

   // Client side time when a modify request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 5 [deprecated = true];

   // Client side time when a modify request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 6;
}

// Specifies an account and what orders to use in the account.
message AccountOrderFilter
{
   // ID of the order's account.
   required sint32 account_id = 1;

   // Specifies either all orders in the account or just orders in the
   // account associated with the trader sending the request.
   optional bool mine = 2 [default = true];

   // Specifies whether only suspended orders or all not suspended orders in the
   // account associated with the trader sending the request.
   optional bool suspended = 3 [default = false];

   // Specifies whether only BUY orders or only SELL orders.
   // This field is associated with Order.Side enum type.
   optional uint32 side = 4;

   // Use only orders of specified contract.
   optional uint32 contract_id = 5;

   // Specifies whether only order(s) expiring during the
   // current/nearest session should be considered.
   optional bool current_day_only = 6 [default=false];
}

// Cancel all orders request.
message CancelAllOrders
{
   // Client side time when a modify request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 1 [deprecated = true];

   // Client side time when a modify request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 4;

   // Client order ID of this cancel request.
   optional string cl_order_id = 2;

   // Specifies an account and what orders to cancel in the account.
   // All orders that meet the criteria (account, mine, suspended etc.) will be canceled.
   // At least one AccountOrderFilter should be present.
   repeated AccountOrderFilter account_order_filter = 3;
}

// Activate suspended (parked) order request.
message ActivateOrder
{
   // Order id assigned by server after last modification.
   required string order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;

   // This client order ID of the order to activate.
   required string orig_cl_order_id = 3;

   // Client order ID of this activation request (will become new client order Id if activation is accepted).
   // Maximum allowed length is 64 bytes.
   required string cl_order_id = 4;

   // Client side time when a modify request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 5 [deprecated = true];

   // Client side time when a modify request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 6;
}

// Modification of order's user attributes.
message ModifyUserAttributes
{
   // ID of the order chain.
   required string chain_order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;

   // List of attributes to modify.
   repeated UserAttribute user_attribute = 3;

   // Flag used by the client for marking the user attributes checked/unchecked.
   // Empty means to leave the flag the same as it was.
   optional bool is_checked = 4;
}

// Placement of a compound order.
message NewCompoundOrder
{
   // Compound order to place.
   required CompoundOrder compound_order = 1;

   // Indicates whether compound order execution shall happen on a partial fill (true or omitted) 
   // or complete fill (false).
   optional bool partial_fills_handling = 2 [default = true];
}

// Compound order.
message CompoundOrder
{
   // Type of the compound order.
   enum Type
   {
      // Order Places Order.
      // [Partial] fill of the first entry triggers [partial] placement of all other orders.
      OPO = 1;

      // Order Cancels Order. This type allows several compound order entires.
      // [Partial] fill of any order triggers [partial] canceling of all other orders.
      OCO = 2;
   }
   // This field is associated with Type enum type.
   required uint32 type = 1;

   // ID of the compound order assigned by client.
   // Maximum allowed length is 64 bytes.
   required string cl_compound_id = 2;

   // List of entires.
   repeated CompoundOrderEntry compound_order_entry = 3;
   
   // Example of usage for next parameters:
   // User places a compound buy order at $50, tick size is equal to 1$, profit_tick_offset = 10,
   // loss_tick_offset = 5, and stop_limit_tick_offset = 15. When buy order is filled, OCO chain with 2 orders
   // is created: sell limit order at $60 and sell stop limit order at $45. If the price moves up to $60, the position
   // will be sold and stop sell order would be cancelled. If the prices moves down to $45, sell limit order is
   // cancelled and sell stop limit order becomes sell limit order at $30.

   // Offset in ticks from fill price (variable ticks size is supported). New order price will be
   // calculated as (fill price + offset) for buy master orders and (price - offset) for sell master orders.
   optional sint32 profit_tick_offset = 4;

   // Offset in ticks from fill price (variable ticks size is supported). New order price will be
   // calculated as (fill price - offset) for buy master orders and (price + offset) for sell master orders.
   optional sint32 loss_tick_offset = 5;

   // Offset in ticks from loss_tick_offset for stop limit orders (variable ticks size is supported).
   // The offset determines the limit price for stop limit order after the stop price is hit.
   optional sint32 stop_limit_tick_offset = 6;
}

// Use existing order.
message UseOrder
{
   // Order id of existing order assigned by server after last modification.
   required string order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;
}

// Entry of a compound order. Only one of optional fields has to be specified.
message CompoundOrderEntry
{
   // Regular order entry.
   optional Order order = 1;

   // Sub-compound order entry.
   optional CompoundOrder compound_order = 2;

   // Existing order entry.
   optional UseOrder use_order = 3;
}

// Suspend (park) order request.
message SuspendOrder
{
   // Order id assigned by server after last modification.
   required string order_id = 1;

   // ID of the order's account.
   required sint32 account_id = 2;

   // This client order ID of the order to suspend (park).
   required string orig_cl_order_id = 3;

   // Client order ID of this suspension request (will become new client order Id if suspension is accepted).
   // Maximum allowed length is 64 bytes.
   required string cl_order_id = 4;

   // Client side time when a modify request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 5 [deprecated = true];

   // Client side time when a modify request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 7;

   // Time when the suspended (parked) order should automatically activate (UTC).
   // Note: use activation_utc_timestamp field instead.
   optional sint64 activation_utc_time = 6 [deprecated = true];

   // Time when the suspended (parked) order should automatically activate (UTC).
   // If specified it's used instead of activation_utc_time field.
   // If neither this nor activation_utc_time field is specified, order must be activated by ActivateOrder request
   optional google.protobuf.Timestamp activation_utc_timestamp = 8;
}

// Status of order.
message OrderStatus
{
   // List of trade subscription IDs this status is related to.
   repeated uint32 subscription_id = 1;

   // True if this is a snapshot related message.
   // Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
   // an indicator of complete snapshot delivery for a particular subscription.
   optional bool is_snapshot = 2;

   // This field is associated with shared_1.OrderStatus.Status enum type.
   required uint32 status = 3;

   // Order ID assigned by server.
   // It is changed by server after each modify request acknowledgment.
   required string order_id = 4;

   // Order ID assigned by server to originally placed order. It stays the same regardless of modification requests.
   required string chain_order_id = 5;

   // Order ID assigned by execution system (e.g. exchange).
   optional string exec_order_id = 6;

   // Last order change time from server perspective (UTC).
   // Note: use status_utc_timestamp field instead.
   optional sint64 status_utc_time = 7 [deprecated = true];

   // Last order change time from server perspective (UTC).
   required google.protobuf.Timestamp status_utc_timestamp = 24;

   // Time when original order was submitted to the execution system by server (UTC).
   // Note: use submission_utc_timestamp field instead.
   optional sint64 submission_utc_time = 8 [deprecated = true];

   // Time when original order was submitted to the execution system by server (UTC).
   required google.protobuf.Timestamp submission_utc_timestamp = 25;

   // Filled quantity.
   required uint32 fill_qty = 9;

   // Number of fill events.
   required uint32 fill_cnt = 10;

   // Average fill price.
   // NOTE: this price is aligned by ContractMetadata.correct_price_scale so don't use it for OTE/UPL calculation but
   // use prices from individual TRADE elements. See also avg_fill_price_correct field.
   required sint64 avg_fill_price = 11;

   // Average fill price in correct price format.
   required double avg_fill_price_correct = 27;

   // Time when order should be submitted to execution system as assigned by server (UTC).
   // Note: use active_at_utc_timestamp field instead.
   optional sint64 active_at_utc_time = 12 [deprecated = true];
   
   // Time when order should be submitted to execution system as assigned by server (UTC).
   optional google.protobuf.Timestamp active_at_utc_timestamp = 26;

   // Remaining (unfilled) order quantity. It is not always equal
   // to order size minus filled size (for example, busted orders violate that).
   required uint32 remaining_qty = 13;

   // order with updated attributes. server may not send it if order attributes remained the same since last update
   optional Order order = 14;

   // List of [last] transactions. In case of initial snapshot (if last_orders_update_utc_time was not set in TradeSubscription)
   // all available transactions are sent. This list can be empty if this status is sent to update order attributes only
   // (e.g. to update prices of trailing orders).
   repeated TransactionStatus transaction_status = 15;

   // User who placed the order, or user on whose behalf the order was placed.
   required string entered_by_user = 16;

   // Statement date when this order was submitted.
   required sint64 first_statement_date = 17;

   // Last statement date this order belongs to. It is set when order is cleaned by a statement report
   // so that order is not 'current' any longer.
   optional sint64 last_statement_date = 18;

   // Multiple OrderStatus and PositionStatus messages in a single ServerMsg can reference the same contract.
   // If the contract is unknown to the client before this ServerMsg, contract meta-data will be added in at least one of them.
   // If in your code you process orders first and positions second then during processing orders you may
   // encounter order with yet unknown contract_id. 
   // In this case you should look for matching contract metadata in positions. 
   // The opposite is also true: contract metadata for positions can be in order status messages.
   repeated ContractMetadata contract_metadata = 19;

   // Id of an account for this order status.
   required sint32 account_id = 20;

   // If the order is part of a compound order then this field describe the structure of the compound.
   optional CompoundOrderStructure compound_order_structure = 21;

   // The number of active (not resolved) hangs on this synthetic strategy order.
   optional uint32 hang_count = 22;

   // Synthetic order's outright properties
   optional SyntheticStrategyProperties strategy_properties = 23;
}

// Status of a specific transaction.
// All attributes are at the transaction moment.
message TransactionStatus
{
   // This field is associated with shared_1.TransactionStatus.Status enum type.
   required uint32 status = 1;

   // Order transaction identifier, unique within order chain.
   required uint64 trans_id = 2;

   // Transaction time assigned by server (UTC).
   // Note: use trans_utc_timestamp field instead.
   optional sint64 trans_utc_time = 3 [deprecated = true];

   // Transaction time assigned by server (UTC).
   required google.protobuf.Timestamp trans_utc_timestamp = 40;

   // Reference transaction ID to the previous fill transaction for a bust, cancel or correction.
   optional uint64 ref_trans_id = 4;

   // If order is modified, this client order ID of the order before modification.
   optional string orig_cl_order_id = 5;

   // Client order ID of the order at the transaction moment.
   required string cl_order_id = 6;

   // Filled quantity for fill transactions or updated quantity for fill correction.
   optional uint32 fill_qty = 7;

   // Fill price for fill transactions or updated price for fill correction.
   optional sint64 fill_price = 8;

   // List of specific per leg trades (more than one for strategies).
   repeated Trade trade = 9;

   // List of leg order fills that contribute to a synthetic strategy order fill.
   // Present if the transaction is of type FILL or FILL_CORRECT and this order is a synthetic strategy order.
   // Mutually exclusive with 'trade' attribute.
   repeated StrategyLegFill strategy_leg_fills = 38;

   // Details of the hang
   optional SyntheticHang synthetic_hang = 39;

   // If order is modified, this is the previous order size.
   optional uint32 prev_order_qty = 10;

   // If order is modified, this is the updated order size.
   optional uint32 order_qty = 11;

   // If order is modified, this is the previous order limit price.
   optional sint64 prev_limit_price = 12;

   // If order is modified, this is the updated order limit price.
   optional sint64 limit_price = 13;

   // If order is modified, this is the previous order stop price.
   optional sint64 prev_stop_price = 14;

   // If order is modified, this is the updated order stop price.
   optional sint64 stop_price = 15;

   // If order is modified, this is the previous visible order size.
   optional uint32 prev_visible_qty = 16;

   // If order is modified, this is the updated visible order size.
   optional uint32 visible_qty = 17;

   // If order is modified, this is the previous min visible order size.
   optional uint32 prev_min_visible_qty = 18;

   // If order is modified, this is the updated min visible order size.
   optional uint32 min_visible_qty = 19;

   // If fill is modified, the previous size is reported here.
   optional uint32 prev_fill_qty = 20;

   // If fill is modified, the previous price is reported here.
   optional sint64 prev_fill_price = 21;

   // If order is modified, this is the previous order type.
   // This field is associated with Order.OrderType enum type.
   optional uint32 prev_order_type = 22;

   // If order is modified, this is the updated order type.
   // This field is associated with Order.OrderType enum type.
   optional uint32 order_type = 23;

   // If order is modified, these are the previous exec instructions.
   // This field is associated with Order.ExecInstruction enum type.
   repeated uint32 prev_exec_instruction = 24;

   // If order is modified, these are the updated exec instructions.
   // This field is associated with Order.ExecInstruction enum type.
   repeated uint32 exec_instruction = 25;

   // If order is modified, this is the previous duration.
   // This field is associated with Order.Duration enum type.
   optional uint32 prev_duration = 26;

   // If order is modified, this is the new duration.
   // This field is associated with Order.Duration enum type.
   optional uint32 duration = 27;

   // If order is modified, this is the previous date then the order should expire  (see Order.good_thru_date).
   optional sint64 prev_good_thru_date = 28;

   // If order is modified, this is the updated date then the order should expire  (see Order.good_thru_date).
   optional sint64 good_thru_date = 29;

   // If order request is rejected, this is rejection code (the list is provided separately).
   optional uint32 reject_code = 30;

   // If present, identifies the counterpart of the order fill, as reported by the execution system.
   optional string fill_counterparty = 31;

   // Order identifier assigned by server when sending the order to execution system.
   optional string route_cl_order_id = 32;

   // Additional transaction details.
   optional string text_message = 33;

   // If order is modified, this is the previous time then the order should expire  (see Order.good_thru_utc_time).
   // Note: use prev_good_thru_utc_timestamp field instead.
   optional sint64 prev_good_thru_utc_time = 34 [deprecated = true];

   // If order is modified, this is the previous time then the order should expire  (see Order.good_thru_utc_timestamp).
   optional google.protobuf.Timestamp prev_good_thru_utc_timestamp = 41;

   // If order is modified, this is the updated time then the order should expire  (see Order.good_thru_utc).
   // Note: use good_thru_utc_timestamp field instead.
   optional sint64 good_thru_utc_time = 35 [deprecated = true];

   // If order is modified, this is the updated time then the order should expire  (see Order.good_thru_utc).
   optional google.protobuf.Timestamp good_thru_utc_timestamp = 42;
   
   // OrderRequest.client_regulatory_algorithm_id value echoed back from the latest order request. 
   optional uint32 client_regulatory_algorithm_id = 36;
   
   // Regulatory Algorithm ID actually sent to the exchange for this order, if any. 
   // Will differ from client_regulatory_algorithm_id if any CQG algorithm was applied to the order.
   optional uint32 effective_regulatory_algorithm_id = 37;

   // MiFID algorithm ID provided with this order request, contents depend on mifid_algorithm_id_type.
   optional string mifid_algorithm_id = 43;

   // Defines the type of mifid_algorithm_id reported. One of MiFIDAlgorithmIdType enum.
   optional uint32 mifid_algorithm_id_type = 44;

   // The MiFID algorithm ID associated with the order request for execution in this account.
   // It may have no relation to mifid_algorithm_id, e.g. in case client supplied a mifid_algorithm_id 
   // and then a server-side algorithm was used, its identifier would be applied to the order instead.
   optional string mifid_applied_algorithm_id = 45;

   // The type of mifid_applied_algorithm_id reported. One of MiFIDAlgorithmIdType enum.
   optional uint32 mifid_applied_algorithm_id_type = 46;

   // Actual value of MiFID Execution Within Firm associated with this order for execution in this account,
   // reflects FCM + route short code mapping if configured.
   optional string mifid_execution_decision = 47;
}

// Trade per specific outright contract.
message Trade
{
   // Trade ID assigned by server, unique within account.
   required string trade_id = 1;

   // Server contract identifier.
   required uint32 contract_id = 2;

   // Brokerage statement date this trade corresponds to (in time format, convert to date only).
   required sint64 statement_date = 3;

   // Time of the trade (UTC).
   // Note: use trade_utc_timestamp field instead.
   optional sint64 trade_utc_time = 4 [deprecated = true];

   // Time of the trade (UTC).
   required google.protobuf.Timestamp trade_utc_timestamp = 12;

   // Exchange trade day this trade corresponds to (in time format, date only value).
   required sint64 trade_date = 5;

   // Trade price.
   required sint64 price = 6;

   // Trade side.
   // This field is associated with Order.Side enum type.
   required uint32 side = 7;

   // Trade size.
   required uint32 qty = 8;

   // If present, identifies the counter-party of the trade, as reported by the execution system
   // (may or may not match counter-party reported for the order fill).
   optional string trade_counterparty = 9;

   // Flag that trade was made as aggressive.
   optional bool is_aggressive = 10;

   // Execution id of the leg fill
   optional string leg_execution_id = 11;
}

// Describes a leg order fill that contributes to a synthetic strategy order fill.
message StrategyLegFill
{
   // Order id for the leg order (the original OrderStatus.order_id)
   required string leg_order_id = 1;

   // Leg_execution_id of the corresponding Trade message for the leg order fill.
   required string leg_execution_id = 2;

   // Quantity of the leg order fill used for this synthetic strategy order fill,
   // decimal (fractional quantities are possible for legs with non-integer quantity ratio).
   required double qty = 3;
}

// Details of hung quantity on a synthetic strategy order or existing hang resolution
message SyntheticHang
{
   // Unique hang identifier supplied by server.
   required sint32 hang_id  = 1;

   // Quantity (of the synthetic strategy order) hung, 0 indicates that hang is resolved.
   required uint32 hung_qty  = 2;

   // Orders participating in a synthetic strategy order hang.
   // Note: this is the original OrderStatus.order_id.
   repeated string order_id = 3;
}

// Compound order structure.
message CompoundOrderStructure
{
   // This field is associated with CompoundOrder.Type enum type.
   // Type of the compound order.
   required uint32 type = 1;

   // ID of the compound order assigned by client.
   required string cl_compound_id = 2;

   // List of entires.
   repeated CompoundOrderStructureEntry compound_order_entry = 3;
}

// Entry of a compound order structure. One of optional fields is specified.
message CompoundOrderStructureEntry
{
   // Regular order id as assigned by server.
   optional string chain_order_id = 1;

   // Sub-compound order structure entry.
   optional CompoundOrderStructure compound_order_structure = 2;
}

// Parameters associated with a concrete leg.
message StrategyOrderLegParameters
{
   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index or LegDefinition.node_index value).
   required uint32 node_index = 1;

   // Account to place order on the leg.
   required sint32 account_id = 2;
}

// Synthetic strategy MKT order parameters
message StrategyMarketOrderParameters
{
   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index).
   required uint32 node_index = 1;

   // For Iceberg orders:
   // 'true' means replenish qty on the filled leg immediately upon receiving primary fill;
   // 'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
   //         is filled or its qty changes for some other reason, e.g. replace request.
   optional bool replenish_on_primary_fill = 2;
}

// Parameters of LMT orders on a leg which is currently working.
message PrimaryOrdersLimit
{
   // Mode of working primary orders with price far from market.
   enum FarFromMarketMode
   {
      // Primary orders will be canceled (won't be placed) if a new target price is far from market.
      NO_ORDERS = 1;

      // Primary orders will be moved away from market (will be left untouched) if a new target price is far from market.
      MOVE_AWAY_ONLY = 2;

      // Primary orders will be left untouched if current and a new target price are both far from market.
      DONT_MOVE = 3;
   }

   // Modes of handling DOM data.
   enum DOMUsageMode
   {
      // Use only top levels of DOMs and produce a single level of primary orders.
      TOP_ONLY = 1;

      // Use multiple levels of DOMs and produce multiple levels of primary orders.
      MULTILEVELS = 2;

      // Produce a single level of primary orders of the full quantity corresponding to the worst DOM prices with a sufficient cumulative quantity.
      FULL_SIZE_WORST_PRICE = 3;

      // Produce a single level of primary orders of the full quantity corresponding
      // to average DOM prices with a sufficient cumulative quantity.
      FULL_SIZE_AVERAGE_PRICE = 4;
   }

   // Place an order only if the quantity available in the monitored leg is at least this much and 
   // to modify a working order only if the quantity available in the monitored leg increases by at least this much.
   // Default is 1.
   optional uint32 min_qty_increment = 1;

   // Queue holders (stacked orders) are additional orders placed in the queue at specified price levels away from the initial working order.
   // Sets the minimum number of orders to include in the queue.
   // Allowed values: 1-10, default is 1.
   optional uint32 queue_holders_min_size = 2;

   // Sets the maximum number of orders to include in the queue.
   // Allowed values: 1-10 and not less than queue_holders_min_size, default is 1.
   optional uint32 queue_holders_max_size = 3;

   // Indicates how many price levels (ticks) to skip between orders in the queue.
   // Allowed range is 1-5, default is 1.
   optional uint32 queue_holders_distance = 4;

   // Indicates how far the market should run before maximizing size of a recently placed order that is now part of the group of stacked orders.
   // Must be less than queue_holders_min_size, default is 0.
   optional uint32 order_size_restore_threshold = 5;

   // Primary Iceberg order visible size in lots.
   optional uint32 visible_qty = 6;

   // Primary Iceberg order min visible size in lots.
   optional uint32 min_visible_qty = 7;

   // Maximal distance between the market price and the old/new limit price of working primary leg
   // orders, which allows modifications of these orders' prices(in ticks).
   // Zero value is acceptable and means that the orders are modified at any distance.
   // 0 is default.
   optional uint32 working_orders_price_range = 8;

   // Minimal difference between the old and the new limit prices of working
   // primary leg orders, which allows modifications of these orders' prices (in ticks).
   optional uint32 min_price_change = 9;

   // Maximum number of leg orders per price level
   optional uint32 primary_orders_fifo_queue_size = 10;

   // Period of updates to the working leg in milliseconds, such that every N ms, 
   // the leg is put where it ought to be placed based upon current prices.
   // Default is to use the server settings.
   optional uint32 force_update_period = 11;

   // Flag that shows whether observed markets must be used for primary orders size calculation or not.
   optional bool ignore_observed_markets = 12;

   // Specifies (in ticks) maximum distance primary order price could be moved from target one while creating best bid/ask.
   optional uint32 max_dimming = 13;

   // Mode of handling primary leg orders with target price far from market. One of FarFromMarketMode enums.
   // Default is to use the server settings.
   optional uint32 far_from_market_mode = 14;

   // Defines if and where server must work quantity that cannot lean onto current best bid/offer.
   // Allowed range 0-9, default is to use the server setting.
   optional int32 ticks_away_to_work = 15;

   // How to work orders considering DOM data. One of DOMUsageMode enums. TOP_ONLY is default.
   optional uint32 dom_usage = 16;
   
   // Work up to this number of orders to get required volume if dom_usage is MULTILEVELS.
   // Allowed range 1-10, default is 1.
   optional uint32 dom_multilevel_qty = 17;
}

// Sniper rule means don't place any primary order. 
// It just watchs markets waiting for the moment when the strategy order's LMT price is available.
// Then secondary orders on all legs must be placed.
message PrimaryOrdersSniper
{
   // Duration for sniper leg orders 
   enum LegDuration
   {
      DAY = 1;

      // Fill and kill
      FAK = 2;

      // Fill or kill
      FOK = 3;
   }

   // One of LegDuration enums.
   required uint32 leg_duration = 1;
}

// LMT secondary orders parameters.
message SecondaryOrdersLimit
{
   // Offset to adjust secondary order price at the moment of place. Default is 0.
   optional double initial_offset = 1;
}

// MKT secondary orders parameters.
message SecondaryOrdersMarket
{
}

// Pay up secondary orders parameters.
message SecondaryOrdersPayUp
{
   // Offset to modify the price of a hung secondary order.
   required double offset = 1;

   // Offset to adjust the secondary order price at the moment of placement.
   optional double initial_offset = 2;

   // One of the conditions below must be set.
   // Condition to check that pointed time interval is passed.
   optional uint32 condition_timeout = 3;

   // Condition to check the opposite market volume.
   optional uint32 condition_absolute_volume = 4;

   // Condition to check the ratio between the opposite side and secondary order sizes.
   optional double condition_opposite_volume_ratio = 5;

   // Condition to check the opposite side and the local side volumes ratio.
   optional double condition_bba_volume_ratio = 6;
}

// Trailing secondary orders parameters.
message SecondaryOrdersTrailing
{
   // Trailing offset.
   required double trailing_offset = 1;

   // Peg that price must follow. One of Order.TrailingPeg enum.
   required uint32 trailing_peg = 2;

   // Offset to adjust secondary order price at the moment of place.
   optional double initial_offset = 3;

   // Maximum distance to trail away from the initial price.
   optional double max_trail = 4;

   // One of the conditions below must be set.
   // Condition that checks the opposite market volume.
   optional uint32 condition_absolute_volume = 5;

   // Condition that checks relation between opposite side and secondary order sizes.
   optional double condition_opposite_volume_ratio = 6;

   // Condition that checks the opposite side and the local side volumes ratio
   optional double condition_bba_volume_ratio = 7;
}

// LMT order parameters for a leg.
message LimitOrderLegDescription
{
   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index or LegDefinition.node_index value).
   required uint32 node_index = 1;

   // All the attributes below are mutually exclusive.
   // Sets the leg as working and place LMT orders.
   optional PrimaryOrdersLimit primary_order_limit = 2;

   // Sets the leg as working and place sniper orders.
   optional PrimaryOrdersSniper primary_order_sniper = 3;

   // Sets the leg as not working and place LMT orders.
   optional SecondaryOrdersLimit secondary_orders_limit = 4;

   // Sets the leg as not working and place MKT orders.
   optional SecondaryOrdersMarket secondary_orders_market = 5;

   // Sets the leg as not working and place payup orders.
   optional SecondaryOrdersPayUp secondary_orders_payup = 6;

   // Sets the leg as not working and place trailing orders.
   optional SecondaryOrdersTrailing secondary_orders_trailing = 7;

   // Indicates how many lots (in fractions) should be filled before the second leg order is placed.
   // Allowed range 0-1.
   // Default is off, the secondary leg placed after all lots are filled on the primary leg.
   optional double proportional_execution_ratio = 8;

   // Determines the size of working orders based on a percentage of the resting volume available in the queue of the monitored leg.
   // Allowed range 0-1000.
   // Default is 1.
   optional double volume_multiplier = 9;

   // Tells the system to work the order if and only if the available quantity in the monitored leg is and remains greater than this value.
   // Default is 0.
   optional uint32 work_threshold = 10;
}

// Parameters for strategy price change depending on filled strategy size.
message PriceShifting
{
   // step (in ticks) of each price change.
   required int32 price_step = 1;

   // Size of strategy order that must be filled to perform next change of strategy order price.
   required uint32 filled_qty_delta = 2;
}

// LMT order parameters of the root or a nested strategy.
message StrategyLimitOrderParameters
{
   // Mode of overfill handling
   enum OverfillMode
   {
      // Overfills are allowed and managed by trader
      MANUAL = 1;

      // Overfills are allowed and must be hedged by the server according to strategy quantity ratios 
      AUTOMATIC_HEDGING = 2;

      // Minimize probability of overfills
      AVOID_OVERFILLS = 3;
   }

   // Defines sizes of what leg orders must be aligned to strategy lots (opposite to work proportionally).
   enum AlignToStrategyLots
   {
      // Both primary and secondary leg orders could work its sizes proportionally (without aligning it to strategy lot)
      NONE = 1;

      // Secondary leg orders must align its size to strategy lots
      SECONDARY_ONLY = 2;

      // Both primary and secondary leg orders align its sizes to strategy lots
      ALL = 3;
   }

   // The way prices for secondary orders are calculated
   enum PricingMethod
   {
      // Respect each strategy lot price independently
      INDEPENDENT_LOT_PRICE = 1;

      // Respect average strategy order price
      AVERAGE_ORDER_PRICE = 2;
   }

   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index value).
   required uint32 node_index = 1;

   // Defines whether replenish quantity on primary fill or not.
   // For Iceberg orders:
   //  'true' means replenish quantity on the filled leg immediately upon receiving primary fill;
   //  'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
   //          is filled or its quantity changes for some other reason, e.g. replace request.
   optional bool replenish_on_primary_fill = 2;

   // Defines mode of overfill handling for this limit SS order. One of OverfillMode enums.
   // AUTOMATIC_HEDGING is default.
   optional uint32 overfill_mode = 3;

   // Defines sizes of what leg orders must be aligned to strategy lots.One of AlignToStrategyLots enums.
   // NONE is default.
   optional uint32 align_to_strategy_lots = 4;

   // The way prices for secondary leg orders are calculated. One of PricingMethod enums.
   // AVERAGE_ORDER_PRICE is default
   optional uint32 pricing_method = 5;

   // Price shifting parameters.
   optional PriceShifting price_shifting = 6;

   // Parameters for strategy legs.
   repeated LimitOrderLegDescription leg_description = 7;
}

// STP order parameters of the root or a nested strategy.
message StrategyStopOrderParameters
{
   // Enumeration of sides of strategy price that STP orders watch for.
   enum StopSide
   {
      // Bid price of strategy must be matched against STP price.
      BID = 1;

      // Ask price of strategy must be matched against STP price.
      ASK = 2;
   }

   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index value).
   required uint32 node_index = 1;

   // The side of strategy price that STP orders watch for. One of StopSide enums.
   required uint32 stop_side = 2;

   // For Iceberg orders:
   //  'true' means replenish qty on the filled leg immediately upon receiving primary fill;
   //  'false' means to 'freeze' the filled leg (don't add any more qty to it) until SS order
   //          is filled or its qty changes for some other reason, e.g. replace request.
   optional bool replenish_on_primary_fill = 3;
}

// Aggregation market taking mode: the order is held on the server until the price becomes available in at least one market; 
// at which time, the server sends an order to the exchange.
message MarketTakingParameters
{
   // Type of order placed for the leg.
   enum MarketTakingLimitOrderType
   {
      LMT = 1;

      MKT = 2;
   }

   // Allocation percent (in range 0...1) for the leg (must total 100% among all legs).
   required double allocation_percent = 1;

   // Time period (in ms) that the order can work (after exchange ack)
   // before the server considers it timed out and cancels it (0 means 'never',
   // leaves order working until filled, cancelled, or expired).
   required uint32 working_timeout = 2;

   // Type of order placed for the leg. One of MarketTakingLimitOrderType enums.
   required uint32 order_type = 3;
}

// Aggregation market making mode: the order is sent immediately to the exchanges based on the allocation percent. 
// The server then manages the orders to get them filled as quickly as possible at the given price.
message MarketMakingParameters
{
   // Allocation percent (in range 0...1) for the leg (doesn't have to total 100% allocation among all legs).
   // Default is 0, the market making mode is turned off for the leg. 
   optional double allocation_percent = 1;

   // Visible size in lots.
   optional uint32 visible_qty = 2;

   // Min visible size in lots.
   optional uint32 min_visible_qty = 3;

   // Visible size of native Iceberg.
   optional uint32 native_visible_qty = 4;
}

// Description of aggregation strategy legs.
message AggregationLegDescription
{
   // Node index in the strategy definition the parameters are related to (LegDefinition.node_index value).
   required uint32 node_index = 1;

   // Threshold value for available quotes quantity to be considered
   // (the quantities under this value are ignored).
   optional uint32 working_threshold = 2;

   // The leg is executed in market taking mode.
   required MarketTakingParameters market_taking_parameters = 3;

   // The leg is executed in market making mode.
   required MarketMakingParameters market_making_parameters = 4;
}

message StrategyAggregationParameters
{
   // Mode of overfill handling.
   enum AggrOverfillMode
   {
      // Minimize probability of overfills: don't place market taking LMT until existing market making LMT on other legs have quantity reduction acknowledge.
      AVOID_OVERFILLS = 1;

      // Place market taking LMTs and then attempt to reduce market making LMT quantity on other legs.
      // There is a window of time where leg orders may be working that total more than the strategy order quantity.
      ACCEPT_OVERFILL = 2;

      // Place market taking LMT and wait to reduce market making LMT qty on other legs until
      // the market taking LMT are filled (or cancelled after timeout).
      // There is a much larger window of time where leg orders
      // may be working that total more than the strategy order qty,
      // but market making LMT don't lose their place in queue.
      PRESERVE_QUEUE_POSITION = 3;
   }

   // Node index in the strategy definition the parameters are related to (StrategyDefinition.node_index).
   required uint32 node_index = 1;

   // Mode of overfill handling. One of AggrOverfillMode enums
   required uint32 overfill_mode = 2;

   // Price shifting parameters.
   optional PriceShifting price_shifting = 3;

   // Aggregation legs parameters.
   repeated AggregationLegDescription pattern_legs = 4;
}

// Defines how a placed synthetic strategy order will be executed.
message StrategyTradingParameters
{
   // Parameters applied only to a MKT order.
   repeated StrategyMarketOrderParameters market_order_parameters = 1;

   // Parameters applied only to a LMT order.
   repeated StrategyLimitOrderParameters limit_order_parameters = 2;

   // Parameters applied only to a STP order.
   repeated StrategyStopOrderParameters stop_order_parameters = 3;

   // Parameters applied only to an aggregation strategy.
   repeated StrategyAggregationParameters aggregation_parameters = 4;

   // Individual strategy leg parameters.
   repeated StrategyOrderLegParameters leg_parameters = 5;
}

// Status of a contract open positions and purchase and sales for a specific account for the current day
// (contractId and accountId are used as a key for updates).
// Contract position is deleted when all open positions and purchase and sales groups are deleted.
message PositionStatus
{
   // List of trade subscription IDs this status is related to.
   repeated uint32 subscription_id = 1;

   // True if this is a snapshot related message.
   // Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
   // an indicator of complete snapshot delivery.
   optional bool is_snapshot = 2;

   // Account this position belongs to.
   required sint32 account_id = 3;

   // Contract ID assigned by server.
   required uint32 contract_id = 4;

   // True if open positions are short (result of sell operations), long otherwise.
   required bool is_short_open_position = 5;

   // List of new/ updated or deleted open positions.
   // NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
   repeated OpenPosition open_position = 6;

   // List of purchase and sales groups. This group represent offset trades (usually one sell and one buy)
   // NOTE: full list is sent only in a snapshot, updates include only added, changed and deleted records.
   repeated PurchaseAndSalesGroup purchase_and_sales_group = 7;

   // Multiple OrderStatus and PositionStatus messages in a single ServerMsg can reference the same contract.
   // If the contract is unknown to the client before this ServerMsg, contract meta-data will be added in at least one of them.
   // If in your code you process orders first and positions second then during processing orders you may
   // encounter order with yet unknown contract_id. 
   // In this case you should look for matching contract metadata in positions. 
   // The opposite is also true: contract metadata for positions can be in order status messages.
   optional ContractMetadata contract_metadata = 8;
}

// Account and contract open position.
// There could be more than one position per account and contract.
// (id is used as a key for updates).
message OpenPosition
{
   // Surrogate id as a key for updates.
   required sint32 id = 1;

   // Position size, zero means that this position is deleted.
   required uint32 qty = 2;

   // Position average price.
   // NOTE: Since it could be an aggregated position price is sent in correct format directly.
   required double price = 3;

   // Exchange specific trade date when the position was open or last changed (date only value).
   required sint64 trade_date = 4;

   // Statement date (date value only).
   required sint64 statement_date = 5;

   // UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
   // Note: use trade_utc_timestamp field instead.
   optional sint64 trade_utc_time = 6 [deprecated = true];

   // UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
   optional google.protobuf.Timestamp trade_utc_timestamp = 8;

   // True if the price is an aggregated position price.
   required bool is_aggregated = 7;
}

// Purchase and sales group that represents offset trades (usually one sell and one buy trade)
message PurchaseAndSalesGroup
{
   // Surrogate id as a key for updates.
   required sint32 id = 1;

   // Profit/ loss (in contract currency) of the group.
   required double realized_profit_loss = 2;

   // list of matched trades in a group
   // in case of group updates the whole list is sent
   repeated MatchedTrade matched_trade = 3;
}


// Specific trade or position that is a part of a purchase and sales group.
// (id is used as a key for updates).
message MatchedTrade
{
   // Matched size.
   // Zero means matched trade is deleted.
   required uint32 qty = 1;

   // True if this is a short trade (e.g. result of sell operation), long otherwise.
   optional bool is_short = 2;

   // Trade or position average price.
   // NOTE: Since it could be an aggregated position price is sent in correct format directly.
   required double price = 3;

   // Trade date (date value only).
   required sint64 trade_date = 4;

   // Statement date (date value only).
   required sint64 statement_date = 5;

   // UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
   // Note: use trade_utc_timestamp field instead.
   optional sint64 trade_utc_time = 6 [deprecated = true];

   // UTC trade time (including date) if available, it might not be available e.g. for the previous day positions.
   optional google.protobuf.Timestamp trade_utc_timestamp = 8;

   // True if the price is an aggregated position price.
   required bool is_aggregated = 7;
}

// Status of the collateral for a specific account.
// An update is sent once it is changed, updates might be consolidated in case of frequent changes.
message CollateralStatus
{
   // List of trade subscription IDs this status is related to.
   repeated uint32 subscription_id = 1;

   // True if this is a snapshot related message.
   // Since snapshot might be sent in several messages (including none), client should use TradeSnapshotCompletion message as
   // an indicator of complete snapshot delivery for a particular subscription.
   optional bool is_snapshot = 2;

   // Account id of this status.
   required sint32 account_id = 3;

   // Currency code of margin and PP values (ISO 4217 based).
   required string currency = 4;

   // Current total margin.
   required double total_margin = 5;

   // Available account funds including balance, realized profit (or loss), collateral and credits.
   // OTE and MVO are included regarding the account risk parameters.
   required double purchasing_power = 6;
   
   // Open trade equity, or potential profit (or loss) from futures and future-style options positions 
   // based on opening price of the position and the current future trade/best bid/best ask 
   // (regarding to the risk account settings) or settlement price if trade is not available.
   // Included if purchasing power depends on it.
   optional double ote = 7;
   
   // Market value of options calculated as the current market trade/best bid/best ask of the option 
   // (regarding to the risk account settings) times the number of options 
   // (positive for long options and negative for short options) in the portfolio.
   // Included if purchasing power depends on it.
   optional double mvo = 8;

   // Market value of futures calculated as the current market trade/best bid/best ask 
   // (regarding to the risk account settings) times the number of futures 
   // (positive for long and negative for short) in the portfolio.
   // Included if applicable.
   optional double mvf = 10;

   // Allowable margin credit of the account
   optional double margin_credit = 9;
}

// Request to resolve previously reported hung quantity on a synthetic strategy order by 
// 1) placing orders to offset filled leg position(s) at current mkt price(s) and (simultaneously) 
// 2) cancelling the hung quantity.
message SyntheticLiquidate
{
   // Id of an account that is used to place an order.
   required sint32 account_id = 1;

   // Order id assigned by server after last modification.
   required string order_id = 2;

   // Id of the hang from the SyntheticHang message.
   required sint32 hang_id = 3;

   // Client side time when a request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 4 [deprecated = true];

   // Client side time when a request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 5;
}

// Request to resolve previously reported hung quantity on a synthetic strategy order by 
// 1) placing LMT orders to offset filled leg position(s) at their fill price(s) and (simultaneously) 
// 2) cancelling the hung quantity.
message SyntheticScratch
{
   // Id of an account that is used to place an order.
   required sint32 account_id = 1;

   // Order id assigned by server after last modification.
   required string order_id = 2;

   // Id of the hang from the SyntheticHang message.
   required sint32 hang_id = 3;

   // Client side time when a request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 4 [deprecated = true];

   // Client side time when a request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 5;
}

// Modify an order to get an immediate fill
// (on either the entire order or previously reported hanging quantity on a synthetic strategy order).
message GoMarket
{
   // Id of an account that is used to place an order.
   required sint32 account_id = 1;

   // Order id assigned by the server after the last modification.
   required string order_id = 2;

   // Id of the hang from the SyntheticHang message, if this request applies to hung quantity on a synthetic strategy order;
   // Not set, if this request applies to the whole order.
   optional sint32 hang_id = 3;

   // Client side time when a request was submitted (UTC).
   // Note: use when_utc_timestamp field instead.
   optional sint64 when_utc_time = 4 [deprecated = true];

   // Client side time when a request was submitted (UTC).
   // If specified it's used instead of when_utc_time field (at least one of these fields has to be specified).
   optional google.protobuf.Timestamp when_utc_timestamp = 5;
}

////------------------------------------------
//// Market Data messaging

// Subscription to market data.
// If it is necessary to change subscription level client should send a new subscription request with the same ID 
// but a new subscription level.
message MarketDataSubscription
{
   // Level or subscription, each new level is a promotion of the previous one.
   enum Level
   {
      // Unsubscribe.
      NONE = 0;

      // Get trade and settlement quotes.
      TRADES = 1;

      // Get trades, settlement and best ask & bid without volumes.
      TRADES_BBA = 2;

      // Get trades, settlement and best ask & bid with volumes.
      TRADES_BBA_VOLUMES = 3;

      // All price data including DOM.
      TRADES_BBA_DOM = 4;
   }

   // Contract ID to subscribe (see symbol resolution report).
   // This is client's responsibility to re-subscribe in case of symbol resolution update.
   required uint32 contract_id = 1;

   // Subscription level.
   // This field is associated with Level enum type.
   required uint32 level = 2;

   // Defines market values array in real-time market data snapshot.
   // False or omitted means that snapshots will contain market values for current trading day only.
   // True means that snapshots will contain market values for several (up to 3) past trading days.
   optional bool include_past_market_values = 3;

   // Optional account cluster ID for account specific data subscriptions.
   optional sint64 account_cluster_id = 4;
}

// Subscription status
message MarketDataSubscriptionStatus
{
   enum StatusCode
   {
      /// success codes (0 - 99)
      SUCCESS = 0;

      // Currently subscription is disconnected because of communication issues
      // NOTE: Clients should not resubscribe in this case, the server will restore subscription with 
      // sending SUCCESS status once communication issues are resolved
      DISCONNECTED = 1;

      /// failure codes (100+)
      // general failure
      FAILURE = 101;

      // Subscription parameters are invalid.
      INVALID_PARAMS = 102;

      // The user is not allowed to be subscribed to this Instrument.
      ACCESS_DENIED = 103;

      // Market data source was deleted because of expiration or by another reason.
      DELETED = 104;

      // The limit of the request number has been violated.
      REQUEST_LIMIT_VIOLATION = 105;

      // Account Cluster ID is required for this subscription but was not provided.
      ACCOUNT_CLUSTER_REQUIRED = 106;
   }

   // Subscription contract ID.
   required uint32 contract_id = 1;

   // Subscription result.
   // This field is associated with StatusCode enum type.
   required uint32 status_code = 2;

   // Effective subscription level.
   // This field is associated with MarketDataSubscription.Level enum type.
   required uint32 level = 3;

   // Possible details of subscription failure.
   optional string text_message = 4;

   // Account cluster ID for account specific data subscriptions.
   optional sint64 account_cluster_id = 5;
}

// Real time data delivery.
// Snapshot is sent as the first message after subscription and may appear periodically when subscribed.
message RealTimeMarketData
{
   // Contract ID assigned by server.
   required uint32 contract_id = 1;

   // Contract quotes. DOM is updated by new volumes per price. zero volume is used to clean this price record from DOM
   repeated Quote quote = 2;

   // True if this is a snapshot (all previously known quotes about this contract should be cleaned).
   optional bool is_snapshot = 3;

   // Collapsing level that was applied by server.
   // NONE if the field is omitted.
   // This field is associated with RealTimeCollapsing.Level enum type.
   optional uint32 collapsing_level = 4;

   // Market values of a contract (e.g. Open/High/Low/Close) for several past trading days.
   // Present in snapshots and in updates if some values are changed (only changed values are included in updates).
   repeated MarketValues market_values = 5;

   // Account cluster ID for account specific data subscriptions.
   optional sint64 account_cluster_id = 6;
}

// Specific quote information
message Quote
{
   // Type of the quote.
   enum Type
   {
      // Trade quote.
      TRADE = 0;

      // Best bid quote.
      // Note that best bid/ask quotes are not guaranteed to be consistent with bid/ask quotes in the short
      // term. Thus, best bid/ask quotes must not be used to update DOM.
      BESTBID = 1;

      // Best ask quote.
      // See the note for BESTBID
      BESTASK = 2;

      // Bid quote (DOM level).
      BID = 3;

      // Ask quote (DOM level).
      ASK = 4;

      // Settlement quote.
      SETTLEMENT = 5;
   }
   // This field is associated with Type enum type.
   required uint32 type = 1;

   // Time of the quote (UTC).
   // It is set only if time of this quote is different from the previous one in the list of quotes.
   optional sint64 quote_utc_time = 2;

   // Quote price.
   required sint32 price = 3;

   // Quote volume (included for BBA only if volume is subscribed).
   // Zero volume for a bid or ask indicates it has been cleared.  It can be a best price and a part of DOM update.
   optional uint64 volume = 4;

   // Optional indicator(s) (e.g. this quote also updates some of Open/High/Low/Close session prices).
   enum Indicator
   {
      // Price of this quote is a new open price of the contract session.
      OPEN = 1;

      // Price of this quote is a new high price of the contract session.
      HIGH = 2;

      // Price of this quote is a new low price of the contract session.
      LOW = 3;

      // Price of this quote is a new close price of the contract session.
      CLOSE = 4;
   }
   // This field is associated with Indicator enum type.
   repeated uint32 indicator = 5;
}

// Market data values of a contract.
message MarketValues
{
   // Open price.
   optional sint32 open_price = 1;

   // High price.
   optional sint32 high_price = 2;

   // Low price.
   optional sint32 low_price = 3;

   // Close price.
   optional sint32 close_price = 4;

   // Yesterday settlement price.
   // NOTE: Available for current trading day only.
   optional sint32 yesterday_settlement = 5;

   // Contract total volume.
   optional uint32 total_volume = 6;

   // Yesterday close price.
   // NOTE: Available for current trading day only.
   optional sint32 yesterday_close = 7;

   // Indicative open price.
   optional sint32 indicative_open = 8;

   // Day index the market values are related to.
   // 0 - current trading day, -1 - yesterday's trading day, etc.
   required sint32 day_index = 9;

   // Open interest.
   optional sint32 open_interest = 10;

   // Contract tick volume.
   optional uint32 tick_volume = 11;

   // Settlement price.
   optional sint32 settlement = 12;

   // Identifiers of fields being cleared.
   repeated uint32 cleared_fields = 13;

   // Trading date the market values belong to.
   required sint64 trade_date = 14;
}

// Read stored user attribute by name.
message ReadUserAttributeRequest
{
   // ID of a request and optional subscription that should be unique enough to match responses and updates with corresponding requests.
   required uint32 request_id = 1;

   // List of names of requested attributes or expressions to match.
   // Empty list means requesting of all available user attributes
   repeated string attribute_name = 2;
}

// Result with requested attributes.
message ReadUserAttributeResult
{
   // Corresponding request ID
   required uint32 request_id = 1;

   // Result code.
   enum ResultCode
   {
      // success codes
      SUCCESS = 0;

      // failure codes (100+)
      FAILURE = 101;

      // The limit of the request number has been violated.
      REQUEST_LIMIT_VIOLATION = 102;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   // List of requested attributes.
   repeated UserAttribute user_attribute = 3;

   // Optional failure details.
   optional string text_message = 4;
}

// Modify or delete user attributes.
message ModifyUserAttributeRequest
{
   // ID of a request that should be unique enough to match responses with corresponding requests.
   required uint32 request_id = 1;

   // List of attributes to modify.
   repeated UserAttribute user_attribute = 2;
}

// User attributes modification result.
message ModifyUserAttributeResult
{
   // Corresponding request ID.
   required uint32 request_id = 1;

   // Result code.
   enum ResultCode
   {
      // success codes
      SUCCESS = 0;

      // failure codes (100+)
      FAILURE = 101;

      // The limit of the request number has been violated.
      REQUEST_LIMIT_VIOLATION = 102;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   // Optional failure details.
   optional string text_message = 3;
}

// Parameters for Time and Sales request.
message TimeAndSalesParameters
{
   // contract id for Time and Sales request.
   required uint32 contract_id = 1;

   // Level or requested Time and Sales data.
   enum Level
   {
      // Get trades with volumes and settlement quotes.
      TRADES = 1;

      // Get trades, settlement and best ask & bid quotes with volumes.
      TRADES_BBA_VOLUMES = 3;
   }
   // This field is associated with Level enum type.
   required uint32 level = 2;

   // Time and Sales period time to start from.
   required sint64 from_utc_time = 3;

   // Optional Time and Sales period finish time.
   // Current server time is used if it is not specified.
   optional sint64 to_utc_time = 4;
}


// Time and sales request (30 days history limit).
message TimeAndSalesRequest
{
   // Request ID, should be unique among currently processed requests.
   required uint32 request_id = 1;

   // parameters of a request, ignored for a DROP operation.
   optional TimeAndSalesParameters time_and_sales_parameters = 2;

   // Type of request.
   enum RequestType
   {
      // Request.
      GET = 1;
   
      // Drop request.
      DROP = 3;
   }
   // This field is associated with RequestType enum type. GET operation is processed by default.
   optional uint32 request_type = 3;
}

message TimeAndSalesReport
{
   // ID of a corresponding request.
   required uint32 request_id = 1;

   // Result code.
   enum ResultCode
   {
      /// success codes  (0 - 99)
      // Request is processed successfully.
      SUCCESS = 0;

      // Delayed request is dropped by a client.
      DROPPED = 2;

      // Request processing status that indicates that currently processing is impossible because of communication issues.
      // NOTE: Clients should not resend requests in this case, the server will restore processing with 
      // sending SUCCESS status once communication issues are resolved.
      // If client is not interested in this request any longer it should send DROP request.
      DISCONNECTED = 4;

      /// failure codes (100+)
      // General failure.
      FAILURE = 101;

      // The user is not allowed to access this instrument data.
      ACCESS_DENIED = 103;

      // Requested information is not found.
      NOT_FOUND = 104; 

      // Requested data is outside of allowed range.
      OUTSIDE_ALLOWED_RANGE = 105;

      // The limit of the request number has been violated.
      REQUEST_LIMIT_VIOLATION = 106;
   }
   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   // List of the requested Time and Sales as quotes.
   // Note that in order to simplify linking of T&S with real time quotes by a client server will atomically include
   // all quotes with the same time-stamp into T&S without splitting the group.
   repeated Quote quote = 3;

   // Time up to which the quotes were included into this report,
   // if there were several with the same time-stamp equal to this time then all are included into the report (UTC).
   // This time is set only for 'up-to-current' requests.
   optional int64 up_to_utc_time = 4;

   // True means that requested data is complete at the moment, false means more report messages are expected for completeness.
   optional bool is_report_complete = 5 [default = true];

   // Optional failure details.
   optional string text_message = 6;

   // Request contains dates partially outside of allowed historical data depth.
   optional bool truncated = 7;
}

// Parameters of a time bar request.
message TimeBarParameters
{
   // Contract id for a bar request.
   required uint32 contract_id = 1;

   // Bar unit type.
   enum BarUnit
   {
      /// Multi-day bars (3 year history limit).

      // yearly bars
      YEAR = 1;

      // semi-annual bars
      SEMI_ANNUAL = 2;

      // quarterly bars
      QUARTER = 3;

      // monthly bars
      MONTH = 4;

      // weekly bars
      WEEK = 5;

      // daily bars
      DAY = 6;

      /// Intra-day bars (3 month history limit).

      // hourly bars
      HOUR = 7;

      // minute bars
      MIN = 8;

   }
   // This field is associated with BarUnit enum type.
   required uint32 bar_unit = 2;

   // Number of units per a single bar for Intra-day bars (must be within 24 hours period).
   optional uint32 units_number = 3;

   // Bars period time to start from.
   required sint64 from_utc_time = 4;

   // Optional bars period finish time.
   // Current server time is used if it is not specified.
   optional sint64 to_utc_time = 5;
   
   // Defines content of the close_price and settlement_price fields in TimeBar.
   // close_price is set to last price if the use_settlements is false or omitted, settlement_price is omitted.
   // settlement_price is set to trade date's settlement price (or omitted for today's bar, if contract did not yet settle) if the use_settlements is true, close_price is omitted.
   optional bool use_settlements = 6;
}

// Request for time bars with optional subscription.
// Number of simultaneous bar update subscriptions is limited, 50 by default.
// In case of subscription updates are sent when a bar opens, closes or when it is corrected. Corrected bars are sent even
// if they are outside of requested time bounds. Range can be expanded with another request if needed.
// Bar also is updated upon expiration the update interval (1 second for Intra-day bars or 1 minute for Inter-day bars), if changed.
message TimeBarRequest
{
   // request or subscription ID
   required uint32 request_id = 1;

   // parameters of a request, ignored for a DROP operation.
   optional TimeBarParameters time_bar_parameters = 2;

   // Type of a bar request.
   enum RequestType
   {
      // Request bars without subscription.
      GET = 1;

      // Request bars with subscription for updates.
      // Note: to_utc_time parameter must not be specified to subscribe.
      SUBSCRIBE = 2;

      // Drop request if server has not completed it yet and/or unsubscribe if already subscribed for updates.
      DROP = 3;
   }
   // This field is associated with RequestType enum type. GET operation is processed by default.
   optional uint32 request_type = 3;
}

// Time bar.
message TimeBar
{
   // Bar start time (UTC).
   required sint64 bar_utc_time = 1;

   // Open price.
   optional sint32 open_price = 2;

   // High price.
   optional sint32 high_price = 3;

   // Low price.
   optional sint32 low_price = 4;

   // Close or last price (if the bar is not closed yet).
   // It is omitted if the TimeBarParameters.use_settlements is true.
   optional sint32 close_price = 5;

   // Bar volume.
   optional uint64 volume = 6;

   // Trade date (in time format), it is set only for the first bar in a requested period
   // and for each first bar of the following trade dates for intra-day bars. Trade date of the bar first day for multi-day bars.
   optional sint64 trade_date = 7;

   // Commodity volume where available, for multi-day bars only.
   optional uint64 commodity_volume = 8;

   // Open interest, for multi-day bars only.
   optional uint32 open_interest = 9;

   // Commodity open interest, for multi-day bars only.
   optional uint32 commodity_open_interest = 10;
   
   // Settlement price, for daily bars only.
   // It is omitted if the TimeBarParameters.use_settlements is false or omitted.
   optional sint32 settlement_price = 11;

   // Tick volume.
   optional uint64 tick_volume = 12;

   // Commodity tick volume where available, for multi-day bars only.
   optional uint64 commodity_tick_volume = 13;
}

// Time bar data response or update.
// Each report contains set of bars. Reports related to a specific request ordered chronologically from the most recent one to the past.
// In case of subscription each report contains 'up_to_utc_time' field.
// Warning: bar updates are not synchronized with real time data so a real time quote that is included into
// a bar might be received either before or after the bar update, use time of a quote for possible real-time bar updates.
message TimeBarReport
{
   // ID of a corresponding request or subscription.
   required uint32 request_id = 1;

   // Status code.
   enum StatusCode
   {
      /// success codes  (0 - 99)
      // Request is processed without subscription (subscription was not requested).
      SUCCESS = 0;

      // Request is processed and subscription is established or restored after disconnection.
      // Data can be resent as a result of the restored subscription.
      SUBSCRIBED = 1;

      // Subscription or delayed request is dropped by a client.
      DROPPED = 2;

      // Unsolicited information update because of subscription.
      UPDATE = 3;

      // Subscription or request processing status that indicates that currently processing is impossible because of communication issues.
      // NOTE: Clients should not resubscribe or resend requests in this case, the server will restore processing with 
      // sending SUCCESS or SUBSCRIBED status once communication issues are resolved.
      // If client is not interested in this request or subscription any longer it should send DROP request.
      DISCONNECTED = 4;

      /// failure codes (100+), subscription (if any) is dropped in case of failure.
      // General failure.
      FAILURE = 101;

      // The user is not allowed to access this data.
      ACCESS_DENIED = 103;

      // Requested information is not found.
      NOT_FOUND = 104; 

      // Requested data is outside of allowed range.
      OUTSIDE_ALLOWED_RANGE = 105;

      // Parameters of a time bar request are invalid.
      INVALID_PARAMS = 106;

      // The limit of the request number has been violated.
      REQUEST_LIMIT_VIOLATION = 107;
   }
   // This field is associated with StatusCode enum type.
   required uint32 status_code = 2;

   // List of time bars.
   repeated TimeBar time_bar = 3;

   // Time up to which the quotes were included into bars, 
   // if there were several with the same time-stamp equal to this time then all are included into the last bar (UTC).
   // This time is set for 'up-to-current' bar requests and bar updates.
   optional int64 up_to_utc_time = 4;

   // True means that requested data is complete at the moment, false means more report messages are expected for completeness.
   optional bool is_report_complete = 5 [default = true];

   // Optional failure details.
   optional string text_message = 6;

   // Request contains dates partially outside of allowed historical data depth.
   optional bool truncated = 7;
}

// VolumeProfile request, 3 month history limit.
message VolumeProfileRequest
{
   // request ID.
   required uint32 request_id = 1;

   // Request parameters.
   optional VolumeProfileParameters volume_profile_parameters = 2;

   // Type of request action.
   enum RequestType
   {
      GET = 1; // request data
      DROP = 3; // cancel a previously issued request
   }

   // This field is associated with RequestType enum type.
   // GET operation is processed by default.
   optional uint32 request_type = 3;
}

// Parameters of a Volume Profile request.
message VolumeProfileParameters
{
   // Contract id for the volume profile request.
   required uint32 contract_id = 1;

   // Both of the next two fields have to be set, otherwise the request will return a failure
   // Start of the time range for volume profile to be calculated for.
   optional sint64 start_utc_time = 2;

   // Exclusive end of the time range for volume profile to be calculated for.
   optional sint64 end_utc_time = 3;
}

// VolumeProfile snapshot response.
message VolumeProfileReport
{
   // ID of the volume profile request.
   required uint32 request_id = 1;

   enum ResultCode
   {
      /// success codes  (0 - 99)
      // Request is processed successfully.
      SUCCESS = 0;

      // Delayed request is dropped by a client.
      DROPPED = 2;

      // Request processing status that indicates that currently
      // processing is impossible because of communication issues.
      // NOTE: Clients should not resend requests in this case,
      // the server will restore processing with sending SUCCESS status
      // once communication issues are resolved. If client is not interested
      // in this request any longer it should send DROP request.
      DISCONNECTED = 4;

      /// failure codes (100+)
      // General failure.
      FAILURE = 101;

      // The user is not allowed to access this instrument data.
      ACCESS_DENIED = 103;

      // Requested information is not found.
      NOT_FOUND = 104; 

      // Requested data is outside of allowed range.
      OUTSIDE_ALLOWED_RANGE = 105;

      // The limit of the request number has been violated.
      REQUEST_LIMIT_VIOLATION = 106;
   }

   // This field is associated with ResultCode enum type.
   required uint32 result_code = 2;

   // Volume profile snapshot items.
   repeated VolumeProfileItem volume_profile_items = 3;

   // Time up to which the quotes were included into this report,
   // if there were several with the same time-stamp equal to this time
   // then all are included into the report (UTC).
   // This time is set only for requests with time range
   // that includes the current time.
   optional int64 up_to_utc_time = 4;

   // Optional failure details.
   optional string text_message = 5;

   // Request contains dates partially outside of allowed historical data depth.
   optional bool truncated = 6;
}

// Volume profile snapshot item.
message VolumeProfileItem
{
   // Price (unique for each volume profile snapshot reported).
   required sint32 price = 1;

   // Total volume of all trades with this price for the time range asked.
   required uint64 volume = 2;
}

// Historical orders request.
message HistoricalOrdersRequest
{
   // Only orders from specified business date (inclusively) is to be returned (date only value in time format).
   required sint64 from_date = 1;

   // Only orders till specified business date (inclusively) is to be returned (date only value in time format).
   // Current business day if the field is omitted.
   optional sint64 to_date = 2;

   // Filter orders by account. Not specifying any account means all accounts of the user.
   repeated sint32 account_id = 3;
}

// Response for historical orders request.
message HistoricalOrdersReport
{
   // List of order statuses matching historical order filter.
   repeated OrderStatus order_status = 1;
}
